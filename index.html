<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>VoiceScribe Pro</title>
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600;700&family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js"></script>
    <script>
        mermaid.initialize({ 
            startOnLoad: false, 
            theme: 'default', 
            securityLevel: 'loose',
            suppressErrors: true,
            flowchart: { htmlLabels: true, curve: 'basis' },
            logLevel: 'error'
        });
    </script>
    <style>
        :root {
            --bg-primary: #0a0a0f;
            --bg-secondary: #12121a;
            --bg-card: #1a1a24;
            --accent: #00d4aa;
            --accent-glow: rgba(0, 212, 170, 0.3);
            --accent-secondary: #7c3aed;
            --text-primary: #ffffff;
            --text-secondary: #a0a0b0;
            --text-muted: #606070;
            --danger: #ef4444;
            --warning: #f59e0b;
            --success: #10b981;
            --border: rgba(255, 255, 255, 0.08);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

        body {
            font-family: 'DM Sans', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            min-height: -webkit-fill-available;
        }

        .app-container { max-width: 100%; min-height: 100vh; display: flex; flex-direction: column; }

        .header {
            padding: 1rem 1.25rem;
            background: linear-gradient(180deg, var(--bg-secondary) 0%, transparent 100%);
            position: sticky; top: 0; z-index: 100; backdrop-filter: blur(20px);
        }
        .header-content { display: flex; align-items: center; justify-content: space-between; }
        .logo { display: flex; align-items: center; gap: 0.75rem; }
        .logo-icon { width: 40px; height: 40px; background: linear-gradient(135deg, var(--accent) 0%, var(--accent-secondary) 100%); border-radius: 12px; display: flex; align-items: center; justify-content: center; font-size: 1.25rem; }
        .logo-text { font-weight: 700; font-size: 1.25rem; background: linear-gradient(135deg, var(--accent) 0%, var(--accent-secondary) 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .header-badges { display: flex; gap: 0.5rem; align-items: center; }

        .status-badge { padding: 0.375rem 0.75rem; border-radius: 20px; font-size: 0.7rem; font-weight: 600; display: flex; align-items: center; gap: 0.375rem; }
        .status-badge.idle { background: rgba(160, 160, 176, 0.15); color: var(--text-secondary); }
        .status-badge.recording { background: rgba(239, 68, 68, 0.2); color: var(--danger); animation: pulse 1.5s infinite; }
        .status-badge.processing { background: rgba(245, 158, 11, 0.2); color: var(--warning); }
        .status-badge.background { background: rgba(124, 58, 237, 0.2); color: var(--accent-secondary); }
        .status-dot { width: 8px; height: 8px; border-radius: 50%; background: currentColor; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }

        .main-content { flex: 1; padding: 1rem; display: flex; flex-direction: column; gap: 1rem; padding-bottom: 2rem; }

        /* API Keys */
        .api-section { background: var(--bg-card); border-radius: 16px; padding: 1rem; }
        .api-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem; }
        .api-box { background: var(--bg-secondary); border-radius: 12px; padding: 0.75rem; }
        .api-box-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem; }
        .api-box-title { font-size: 0.7rem; font-weight: 600; color: var(--text-muted); }
        .api-box-link { font-size: 0.65rem; color: var(--accent); text-decoration: none; }
        .api-box input { width: 100%; padding: 0.5rem; border: 1px solid var(--border); border-radius: 8px; background: var(--bg-primary); color: var(--text-primary); font-size: 0.75rem; }
        .api-box input:focus { outline: none; border-color: var(--accent); }
        .api-box .saved { display: flex; align-items: center; gap: 0.25rem; color: var(--accent); font-size: 0.7rem; }
        .api-box .change-btn { background: none; border: none; color: var(--text-muted); font-size: 0.65rem; cursor: pointer; text-decoration: underline; margin-left: auto; }
        .api-save-btn { grid-column: span 2; padding: 0.625rem; border: none; border-radius: 10px; background: var(--accent); color: white; font-weight: 600; cursor: pointer; font-size: 0.85rem; }

        /* Tabs */
        .tabs { display: flex; background: var(--bg-secondary); border-radius: 16px; padding: 0.25rem; gap: 0.25rem; overflow-x: auto; }
        .tab { flex: 1; padding: 0.7rem 0.25rem; border: none; background: transparent; color: var(--text-secondary); font-family: inherit; font-size: 0.7rem; font-weight: 600; border-radius: 12px; cursor: pointer; white-space: nowrap; min-width: 60px; }
        .tab.active { background: var(--bg-card); color: var(--text-primary); box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3); }
        .tab-content { display: none; flex: 1; flex-direction: column; gap: 1rem; }
        .tab-content.active { display: flex; }

        /* Settings */
        .settings-card { background: var(--bg-card); border-radius: 16px; padding: 1rem; }
        .setting-row { display: flex; align-items: center; justify-content: space-between; }
        .setting-info h4 { font-size: 0.85rem; margin-bottom: 0.125rem; }
        .setting-info p { font-size: 0.7rem; color: var(--text-muted); }
        .toggle-switch { position: relative; width: 48px; height: 26px; flex-shrink: 0; }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .toggle-slider { position: absolute; cursor: pointer; inset: 0; background: var(--bg-secondary); border-radius: 26px; transition: 0.3s; }
        .toggle-slider:before { position: absolute; content: ""; height: 20px; width: 20px; left: 3px; bottom: 3px; background: white; border-radius: 50%; transition: 0.3s; }
        .toggle-switch input:checked + .toggle-slider { background: var(--accent); }
        .toggle-switch input:checked + .toggle-slider:before { transform: translateX(22px); }

        /* Recording */
        .recording-section { display: flex; flex-direction: column; align-items: center; gap: 1rem; padding: 1.25rem 1rem; }
        .record-button-container { position: relative; }
        .record-button { width: 90px; height: 90px; border-radius: 50%; border: none; background: linear-gradient(135deg, var(--accent) 0%, var(--accent-secondary) 100%); cursor: pointer; display: flex; align-items: center; justify-content: center; box-shadow: 0 8px 32px var(--accent-glow); transition: transform 0.2s; }
        .record-button:active { transform: scale(0.95); }
        .record-button.recording { background: var(--danger); box-shadow: 0 8px 32px rgba(239, 68, 68, 0.4); animation: pulseBtn 1s infinite; }
        .record-button.processing { background: var(--warning); pointer-events: none; }
        @keyframes pulseBtn { 0%, 100% { box-shadow: 0 8px 32px rgba(239, 68, 68, 0.4); } 50% { box-shadow: 0 8px 48px rgba(239, 68, 68, 0.6); } }
        .record-button svg { width: 36px; height: 36px; fill: white; }
        .record-rings { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 130px; height: 130px; border-radius: 50%; border: 2px solid var(--danger); opacity: 0; pointer-events: none; }
        
        /* Pause Button */
        .pause-button {
            width: 50px; height: 50px; border-radius: 50%; border: none;
            background: var(--warning); cursor: pointer;
            display: none; align-items: center; justify-content: center;
            box-shadow: 0 4px 16px rgba(245, 158, 11, 0.4);
            transition: transform 0.2s, background 0.2s;
            position: absolute; right: -60px; top: 50%; transform: translateY(-50%);
        }
        .pause-button:active { transform: translateY(-50%) scale(0.95); }
        .pause-button svg { width: 24px; height: 24px; fill: white; }
        .pause-button.visible { display: flex; }
        .pause-button.paused { background: var(--success); }
        
        /* Paused state */
        .record-button.paused { 
            background: var(--warning); 
            box-shadow: 0 8px 32px rgba(245, 158, 11, 0.4); 
            animation: none;
        }
        .status-badge.paused { background: rgba(245, 158, 11, 0.2); color: var(--warning); }
        .timer.paused { color: var(--warning); animation: timerBlink 1s infinite; }
        @keyframes timerBlink { 0%, 100% { opacity: 1; } 50% { opacity: 0.4; } }
        .record-button-container.recording .record-rings { animation: ringPulse 1.5s infinite; }
        @keyframes ringPulse { 0% { transform: translate(-50%, -50%) scale(0.7); opacity: 0.8; } 100% { transform: translate(-50%, -50%) scale(1.3); opacity: 0; } }
        .timer { font-family: 'Space Mono', monospace; font-size: 1.75rem; color: var(--text-primary); }
        .record-hint { font-size: 0.75rem; color: var(--text-muted); text-align: center; }
        .visualizer { display: flex; align-items: center; justify-content: center; gap: 3px; height: 40px; }
        .visualizer-bar { width: 5px; background: linear-gradient(180deg, var(--accent) 0%, var(--accent-secondary) 100%); border-radius: 3px; }
        .chunk-indicator { background: rgba(124, 58, 237, 0.2); color: var(--accent-secondary); padding: 0.3rem 0.6rem; border-radius: 8px; font-size: 0.7rem; font-weight: 600; display: none; }
        .chunk-indicator.active { display: block; }

        /* Progress */
        .progress-section { background: var(--bg-card); border-radius: 12px; padding: 1rem; display: none; }
        .progress-section.active { display: block; }
        .progress-title { font-size: 0.8rem; margin-bottom: 0.5rem; }
        .progress-bar { height: 6px; background: var(--bg-secondary); border-radius: 3px; overflow: hidden; }
        .progress-fill { height: 100%; background: var(--accent); border-radius: 3px; transition: width 0.3s; }
        .progress-text { font-size: 0.7rem; color: var(--text-muted); margin-top: 0.375rem; }

        /* Speakers */
        .speaker-quick-select { background: var(--bg-card); border-radius: 16px; padding: 1rem; }
        .section-title { font-size: 0.7rem; text-transform: uppercase; letter-spacing: 0.1em; color: var(--text-muted); margin-bottom: 0.5rem; }
        .speaker-chips { display: flex; flex-wrap: wrap; gap: 0.4rem; }
        .speaker-chip { padding: 0.4rem 0.8rem; border-radius: 16px; border: 2px solid var(--border); background: transparent; color: var(--text-secondary); font-family: inherit; font-size: 0.75rem; font-weight: 600; cursor: pointer; }
        .speaker-chip.active { border-color: var(--accent); color: var(--accent); background: rgba(0, 212, 170, 0.1); }
        .speaker-chip.add { border-style: dashed; color: var(--text-muted); }
        .speaker-chip.recording-active { animation: speakerPulse 1s infinite; }
        @keyframes speakerPulse { 0%, 100% { box-shadow: 0 0 0 0 rgba(0, 212, 170, 0.4); } 50% { box-shadow: 0 0 0 6px rgba(0, 212, 170, 0); } }
        .speaker-1 { color: #00d4aa !important; border-color: #00d4aa !important; }
        .speaker-1.active { background: rgba(0, 212, 170, 0.15) !important; }
        .speaker-2 { color: #7c3aed !important; border-color: #7c3aed !important; }
        .speaker-2.active { background: rgba(124, 58, 237, 0.15) !important; }
        .speaker-3 { color: #f59e0b !important; border-color: #f59e0b !important; }
        .speaker-3.active { background: rgba(245, 158, 11, 0.15) !important; }
        .speaker-4 { color: #ef4444 !important; border-color: #ef4444 !important; }
        .speaker-4.active { background: rgba(239, 68, 68, 0.15) !important; }
        .speaker-5 { color: #3b82f6 !important; border-color: #3b82f6 !important; }
        .speaker-5.active { background: rgba(59, 130, 246, 0.15) !important; }
        .language-row { display: flex; align-items: center; gap: 0.5rem; margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid var(--border); }
        .language-row label { font-size: 0.7rem; color: var(--text-muted); }
        .control-select { flex: 1; padding: 0.4rem 0.6rem; border: 1px solid var(--border); border-radius: 8px; background: var(--bg-secondary); color: var(--text-primary); font-size: 0.75rem; }

        /* Transcript */
        .transcript-section { flex: 1; background: var(--bg-card); border-radius: 16px; padding: 1rem; display: flex; flex-direction: column; min-height: 160px; }
        .transcript-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem; }
        .transcript-count { color: var(--accent); font-size: 0.75rem; font-weight: 600; }
        .new-btn { background: rgba(239, 68, 68, 0.15); border: none; color: var(--danger); font-size: 0.65rem; font-weight: 600; padding: 0.3rem 0.5rem; border-radius: 6px; cursor: pointer; }
        .new-btn:active { transform: scale(0.95); }
        .transcript-area { flex: 1; overflow-y: auto; -webkit-overflow-scrolling: touch; }
        .transcript-entry { margin-bottom: 0.875rem; }
        .transcript-speaker { display: flex; align-items: center; gap: 0.4rem; margin-bottom: 0.2rem; }
        .speaker-label { font-size: 0.65rem; font-weight: 600; padding: 0.1rem 0.4rem; border-radius: 6px; }
        .label-speaker-1 { color: #00d4aa; background: rgba(0, 212, 170, 0.15); }
        .label-speaker-2 { color: #7c3aed; background: rgba(124, 58, 237, 0.15); }
        .label-speaker-3 { color: #f59e0b; background: rgba(245, 158, 11, 0.15); }
        .label-speaker-4 { color: #ef4444; background: rgba(239, 68, 68, 0.15); }
        .label-speaker-5 { color: #3b82f6; background: rgba(59, 130, 246, 0.15); }
        .transcript-time { font-size: 0.55rem; color: var(--text-muted); font-family: 'Space Mono', monospace; }
        .transcript-text { font-size: 0.85rem; line-height: 1.5; color: var(--text-primary); }
        .empty-state { flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; color: var(--text-muted); text-align: center; padding: 1.5rem; }
        .empty-state svg { width: 48px; height: 48px; margin-bottom: 0.75rem; opacity: 0.5; }

        /* ============ NOTES & DRAWING TAB ============ */
        .notes-container { display: flex; flex-direction: column; gap: 1rem; flex: 1; }
        
        /* Notes Textarea */
        .notes-section { background: var(--bg-card); border-radius: 16px; padding: 1rem; }
        .notes-textarea {
            width: 100%;
            min-height: 120px;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 0.75rem;
            color: var(--text-primary);
            font-family: inherit;
            font-size: 0.9rem;
            line-height: 1.6;
            resize: vertical;
        }
        .notes-textarea:focus { outline: none; border-color: var(--accent); }
        .notes-textarea::placeholder { color: var(--text-muted); }
        .notes-count { font-size: 0.65rem; color: var(--text-muted); margin-top: 0.5rem; text-align: right; }

        /* Drawing Canvas */
        .canvas-section { background: var(--bg-card); border-radius: 16px; padding: 1rem; flex: 1; display: flex; flex-direction: column; }
        .canvas-toolbar {
            display: flex; flex-wrap: wrap; gap: 0.5rem; margin-bottom: 0.75rem;
            padding-bottom: 0.75rem; border-bottom: 1px solid var(--border);
        }
        .tool-group { display: flex; gap: 0.25rem; align-items: center; }
        .tool-btn {
            width: 36px; height: 36px; border-radius: 10px; border: 2px solid var(--border);
            background: var(--bg-secondary); color: var(--text-secondary);
            font-size: 1rem; cursor: pointer; display: flex; align-items: center; justify-content: center;
            transition: all 0.2s;
        }
        .tool-btn:active { transform: scale(0.95); }
        .tool-btn.active { border-color: var(--accent); color: var(--accent); background: rgba(0, 212, 170, 0.1); }
        .tool-btn.danger { color: var(--danger); }
        .tool-btn.danger:hover { border-color: var(--danger); }
        
        .color-btn {
            width: 28px; height: 28px; border-radius: 50%; border: 2px solid transparent;
            cursor: pointer; transition: all 0.2s;
        }
        .color-btn.active { border-color: white; transform: scale(1.15); box-shadow: 0 0 8px rgba(255,255,255,0.3); }
        
        .size-slider {
            width: 80px; height: 6px; -webkit-appearance: none; appearance: none;
            background: var(--bg-secondary); border-radius: 3px; outline: none;
        }
        .size-slider::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none;
            width: 18px; height: 18px; border-radius: 50%;
            background: var(--accent); cursor: pointer;
        }
        .size-label { font-size: 0.65rem; color: var(--text-muted); min-width: 25px; text-align: center; }
        
        .canvas-wrapper {
            flex: 1; background: #ffffff; border-radius: 12px; overflow: hidden;
            position: relative; min-height: 250px; touch-action: none;
        }
        #drawingCanvas {
            width: 100%; height: 100%; cursor: crosshair;
            touch-action: none;
        }

        /* AI Analysis Tab */
        .ai-section-title { font-size: 0.75rem; font-weight: 600; color: var(--text-muted); margin-bottom: 0.5rem; margin-top: 0.5rem; }
        .ai-section-title:first-of-type { margin-top: 0; }
        .ai-actions { display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; margin-bottom: 0.75rem; }
        .ai-btn { padding: 0.75rem; border: none; border-radius: 12px; background: var(--bg-card); color: var(--text-primary); font-family: inherit; font-size: 0.8rem; font-weight: 600; cursor: pointer; display: flex; flex-direction: column; align-items: center; gap: 0.25rem; transition: all 0.2s; border: 2px solid transparent; }
        .ai-btn:hover { border-color: var(--accent); }
        .ai-btn:active { transform: scale(0.98); }
        .ai-btn.processing { opacity: 0.6; pointer-events: none; }
        .ai-btn.schema-btn { background: linear-gradient(135deg, var(--bg-card) 0%, rgba(124, 58, 237, 0.1) 100%); }
        .ai-btn.schema-btn:hover { border-color: var(--accent-secondary); }
        .ai-btn-icon { font-size: 1.25rem; }
        .ai-btn-label { font-size: 0.7rem; color: var(--text-muted); }
        .ai-result { background: var(--bg-card); border-radius: 16px; padding: 1rem; flex: 1; overflow-y: auto; margin-bottom: 0.75rem; }
        .ai-result-title { font-size: 0.8rem; color: var(--accent); margin-bottom: 0.75rem; display: flex; align-items: center; gap: 0.5rem; }
        .ai-result-content { font-size: 0.85rem; line-height: 1.6; white-space: pre-wrap; }
        .ai-result-empty { color: var(--text-muted); text-align: center; padding: 2rem; }
        
        /* Mermaid Schema */
        .mermaid-container { background: var(--bg-card); border-radius: 16px; padding: 1rem; border: 2px solid var(--accent-secondary); }
        .mermaid-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem; padding-bottom: 0.5rem; border-bottom: 1px solid var(--border); }
        .mermaid-header span { font-size: 0.85rem; font-weight: 600; color: var(--accent-secondary); }
        .mermaid-copy-btn { padding: 0.4rem 0.75rem; border: none; border-radius: 8px; background: var(--bg-secondary); color: var(--text-secondary); font-size: 0.7rem; cursor: pointer; }
        .mermaid-copy-btn:active { transform: scale(0.95); }
        .mermaid-render { background: #ffffff; border-radius: 12px; padding: 1rem; min-height: 150px; max-height: 500px; overflow: auto; }
        .mermaid-render svg { max-width: 100%; height: auto; display: block; margin: 0 auto; }
        .mermaid-code-details { margin-top: 0.75rem; }
        .mermaid-code-details summary { font-size: 0.7rem; color: var(--text-muted); cursor: pointer; padding: 0.5rem; }
        .mermaid-code { background: var(--bg-secondary); border-radius: 8px; padding: 0.75rem; font-family: 'Space Mono', monospace; font-size: 0.7rem; color: var(--text-secondary); overflow-x: auto; white-space: pre-wrap; word-break: break-all; margin-top: 0.5rem; }
        
        /* Stile per cattura PDF */
        .mermaid-render.pdf-capture { max-height: none; overflow: visible; width: 700px; padding: 20px; }

        /* Stats */
        .stats-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.5rem; margin-bottom: 1rem; }
        .stat-card { background: var(--bg-card); border-radius: 12px; padding: 0.75rem; }
        .stat-value { font-size: 1.5rem; font-weight: 700; }
        .stat-label { font-size: 0.7rem; color: var(--text-muted); }

        /* Export */
        .export-section { display: flex; flex-direction: column; gap: 0.6rem; }
        .export-card { background: var(--bg-card); border-radius: 14px; padding: 0.875rem; display: flex; align-items: center; gap: 0.875rem; cursor: pointer; }
        .export-card:active { transform: scale(0.98); }
        .export-icon { width: 40px; height: 40px; border-radius: 10px; display: flex; align-items: center; justify-content: center; font-size: 1.125rem; }
        .export-icon.pdf { background: rgba(239, 68, 68, 0.2); }
        .export-icon.txt { background: rgba(0, 212, 170, 0.2); }
        .export-icon.audio { background: rgba(124, 58, 237, 0.2); }
        .export-info h3 { font-size: 0.85rem; margin-bottom: 0.1rem; }
        .export-info p { font-size: 0.65rem; color: var(--text-muted); }

        /* Saved */
        .recordings-list { display: flex; flex-direction: column; gap: 0.6rem; }
        .recording-item { background: var(--bg-card); border-radius: 14px; padding: 0.875rem; display: flex; align-items: center; gap: 0.875rem; }
        .recording-item-icon { width: 40px; height: 40px; border-radius: 10px; background: linear-gradient(135deg, var(--accent) 0%, var(--accent-secondary) 100%); display: flex; align-items: center; justify-content: center; flex-shrink: 0; }
        .recording-item-info { flex: 1; min-width: 0; }
        .recording-item-title { font-weight: 600; font-size: 0.85rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .recording-item-meta { font-size: 0.65rem; color: var(--text-muted); }
        .recording-item-badges { display: flex; gap: 0.25rem; margin-top: 0.25rem; flex-wrap: wrap; }
        .item-badge { font-size: 0.55rem; padding: 0.1rem 0.35rem; border-radius: 4px; font-weight: 600; }
        .item-badge.audio { background: rgba(124, 58, 237, 0.2); color: var(--accent-secondary); }
        .item-badge.notes { background: rgba(0, 212, 170, 0.2); color: var(--accent); }
        .item-badge.drawing { background: rgba(245, 158, 11, 0.2); color: var(--warning); }
        .item-badge.ai { background: rgba(239, 68, 68, 0.2); color: var(--danger); }
        .recording-item-actions { display: flex; gap: 0.4rem; }
        .action-btn { width: 32px; height: 32px; border-radius: 8px; border: none; background: var(--bg-secondary); color: var(--text-secondary); cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 0.9rem; }
        .action-btn:active { transform: scale(0.95); }
        .action-btn.delete { color: var(--danger); }
        .action-btn.retranscribe { color: var(--warning); }

        /* Retranscribe section */
        .retranscribe-section { background: var(--bg-card); border-radius: 16px; padding: 1rem; border: 2px dashed var(--border); }
        .retranscribe-btn { width: 100%; padding: 1rem; border: none; border-radius: 12px; background: linear-gradient(135deg, var(--warning) 0%, #d97706 100%); color: white; font-family: inherit; font-size: 0.9rem; font-weight: 600; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 0.5rem; }
        .retranscribe-btn:active { transform: scale(0.98); }
        .retranscribe-info { font-size: 0.7rem; color: var(--text-muted); text-align: center; margin-top: 0.5rem; }

        /* Modal */
        .modal-overlay { position: fixed; inset: 0; background: rgba(0, 0, 0, 0.8); backdrop-filter: blur(10px); display: none; align-items: center; justify-content: center; z-index: 1000; padding: 1rem; }
        .modal-overlay.active { display: flex; }
        .modal { background: var(--bg-card); border-radius: 20px; padding: 1.25rem; width: 100%; max-width: 320px; }
        .modal-title { font-size: 1rem; font-weight: 700; margin-bottom: 0.875rem; }
        .modal-input { width: 100%; padding: 0.7rem 0.875rem; border: 2px solid var(--border); border-radius: 10px; background: var(--bg-secondary); color: var(--text-primary); font-family: inherit; font-size: 0.9rem; margin-bottom: 0.875rem; }
        .modal-input:focus { outline: none; border-color: var(--accent); }
        .modal-buttons { display: flex; gap: 0.6rem; }
        .modal-btn { flex: 1; padding: 0.7rem; border: none; border-radius: 10px; font-family: inherit; font-size: 0.85rem; font-weight: 600; cursor: pointer; }
        .modal-btn.cancel { background: var(--bg-secondary); color: var(--text-secondary); }
        .modal-btn.confirm { background: linear-gradient(135deg, var(--accent) 0%, var(--accent-secondary) 100%); color: white; }

        /* Toast */
        .toast { position: fixed; bottom: 2rem; left: 50%; transform: translateX(-50%) translateY(100px); background: var(--bg-card); color: var(--text-primary); padding: 0.875rem 1.25rem; border-radius: 14px; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4); z-index: 1001; opacity: 0; transition: all 0.3s; border: 1px solid var(--border); max-width: 90%; text-align: center; font-size: 0.85rem; }
        .toast.show { transform: translateX(-50%) translateY(0); opacity: 1; }

        #keepAliveAudio, #audioFileInput { display: none; }

        .bg-warning { background: linear-gradient(90deg, var(--danger), var(--warning)); color: white; padding: 0.5rem 1rem; text-align: center; font-size: 0.75rem; font-weight: 600; display: none; animation: bgPulse 2s infinite; }
        .bg-warning.active { display: block; }
        @keyframes bgPulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }

        /* Drawing preview in saved items */
        .drawing-preview { width: 50px; height: 50px; border-radius: 8px; background: white; object-fit: cover; }
    </style>
</head>
<body>
    <div class="bg-warning" id="bgWarning">üî¥ REGISTRAZIONE IN BACKGROUND - NON CHIUDERE L'APP</div>
    <div class="app-container">
        <header class="header">
            <div class="header-content">
                <div class="logo">
                    <div class="logo-icon">üéôÔ∏è</div>
                    <span class="logo-text">VoiceScribe</span>
                </div>
                <div class="header-badges">
                    <div class="status-badge background" id="bgBadge" style="display: none;"><span>üîí</span></div>
                    <div class="status-badge idle" id="statusBadge">
                        <span class="status-dot"></span>
                        <span id="statusText">Pronto</span>
                    </div>
                </div>
            </div>
        </header>

        <main class="main-content">
            <!-- API Keys -->
            <div class="api-section">
                <div class="api-grid" id="apiGrid" style="grid-template-columns: 1fr;">
                    <div class="api-box">
                        <div class="api-box-header">
                            <span class="api-box-title">üé§ WHISPER (Groq)</span>
                            <a href="https://console.groq.com/keys" target="_blank" class="api-box-link">Ottieni</a>
                        </div>
                        <div id="whisperKeyBox"><input type="password" id="whisperKeyInput" placeholder="gsk_..."></div>
                        <div id="whisperKeySaved" style="display: none;"><span class="saved">‚úì Salvata</span><button class="change-btn" onclick="changeKey('whisper')">Modifica</button></div>
                    </div>
                    <div class="api-box" style="margin-top: 0.5rem;">
                        <div class="api-box-header">
                            <span class="api-box-title">ü§ñ AI ANALISI</span>
                        </div>
                        <select id="aiModelSelect" style="width: 100%; padding: 0.5rem; border: 1px solid var(--border); border-radius: 8px; background: var(--bg-primary); color: var(--text-primary); font-size: 0.75rem; margin-bottom: 0.5rem;">
                            <option value="gemma">üåü Gemma 3 27B (OpenRouter - Gratuito)</option>
                            <option value="llama">‚ö° Llama 3.1 8B (Groq)</option>
                        </select>
                        <div id="gemmaKeyBox">
                            <div class="api-box-header" style="margin-bottom: 0.25rem;">
                                <span class="api-box-title" style="font-size: 0.6rem;">OpenRouter API Key</span>
                                <a href="https://openrouter.ai/keys" target="_blank" class="api-box-link">Ottieni</a>
                            </div>
                            <input type="password" id="gemmaKeyInput" placeholder="sk-or-...">
                        </div>
                        <div id="gemmaKeySaved" style="display: none;"><span class="saved">‚úì Salvata</span><button class="change-btn" onclick="changeKey('gemma')">Modifica</button></div>
                        <div id="llamaKeyBox" style="display: none;">
                            <div class="api-box-header" style="margin-bottom: 0.25rem;">
                                <span class="api-box-title" style="font-size: 0.6rem;">Groq API Key</span>
                                <a href="https://console.groq.com/keys" target="_blank" class="api-box-link">Ottieni</a>
                            </div>
                            <input type="password" id="llamaKeyInput" placeholder="gsk_...">
                        </div>
                        <div id="llamaKeySaved" style="display: none;"><span class="saved">‚úì Salvata</span><button class="change-btn" onclick="changeKey('llama')">Modifica</button></div>
                    </div>
                    <button class="api-save-btn" id="saveKeysBtn">Salva Chiavi</button>
                </div>
            </div>

            <!-- Tabs -->
            <div class="tabs">
                <button class="tab active" data-tab="record">üéôÔ∏è Rec</button>
                <button class="tab" data-tab="notes">üìù Note</button>
                <button class="tab" data-tab="ai">‚ú® AI</button>
                <button class="tab" data-tab="export">üì§</button>
                <button class="tab" data-tab="saved">üíæ</button>
            </div>

            <!-- Record Tab -->
            <div class="tab-content active" id="recordTab">
                <div class="settings-card">
                    <div class="setting-row">
                        <div class="setting-info">
                            <h4>üîí Schermo Spento</h4>
                            <p>Salva chunk ogni 2 min</p>
                        </div>
                        <label class="toggle-switch">
                            <input type="checkbox" id="backgroundToggle">
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                </div>

                <div class="recording-section">
                    <div class="record-button-container" id="recordBtnContainer">
                        <button class="record-button" id="recordBtn">
                            <svg viewBox="0 0 24 24" id="recordIcon">
                                <path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3z"/>
                                <path d="M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z"/>
                            </svg>
                        </button>
                        <button class="pause-button" id="pauseBtn" onclick="togglePause()">
                            <svg viewBox="0 0 24 24" id="pauseIcon">
                                <rect x="6" y="4" width="4" height="16"/>
                                <rect x="14" y="4" width="4" height="16"/>
                            </svg>
                        </button>
                        <div class="record-rings"></div>
                    </div>
                    <div class="timer" id="timer">00:00</div>
                    <div class="chunk-indicator" id="chunkIndicator">Chunk: 0</div>
                    <div class="visualizer" id="visualizer" style="display: none;"></div>
                    <p class="record-hint" id="recordHint">Tocca per registrare</p>
                </div>

                <div class="progress-section" id="progressSection">
                    <div class="progress-title" id="progressTitle">Elaborazione...</div>
                    <div class="progress-bar"><div class="progress-fill" id="progressFill"></div></div>
                    <div class="progress-text" id="progressText">0%</div>
                </div>

                <div class="speaker-quick-select">
                    <div class="section-title">üë§ Speaker</div>
                    <div class="speaker-chips" id="speakerChips"></div>
                    <div class="language-row">
                        <label>Lingua:</label>
                        <select class="control-select" id="languageSelect">
                            <option value="it">üáÆüáπ Italiano</option>
                            <option value="en">üá∫üá∏ English</option>
                            <option value="es">üá™üá∏ Espa√±ol</option>
                            <option value="fr">üá´üá∑ Fran√ßais</option>
                            <option value="de">üá©üá™ Deutsch</option>
                        </select>
                    </div>
                </div>

                <div class="transcript-section">
                    <div class="transcript-header">
                        <div class="section-title">Trascrizione</div>
                        <div style="display: flex; align-items: center; gap: 0.5rem;">
                            <span class="transcript-count" id="transcriptCount">0 frasi</span>
                            <button class="new-btn" onclick="newTranscript()" title="Nuova">üóëÔ∏è Nuova</button>
                        </div>
                    </div>
                    <div class="transcript-area" id="transcriptArea">
                        <div class="empty-state" id="emptyState">
                            <svg viewBox="0 0 24 24" fill="currentColor">
                                <path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3z"/>
                                <path d="M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z"/>
                            </svg>
                            <p>Tocca per registrare</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Notes Tab -->
            <div class="tab-content" id="notesTab">
                <div class="notes-container">
                    <!-- Text Notes -->
                    <div class="notes-section">
                        <div class="section-title">üìù Appunti</div>
                        <textarea class="notes-textarea" id="notesTextarea" placeholder="Scrivi qui i tuoi appunti..."></textarea>
                        <div class="notes-count"><span id="notesCharCount">0</span> caratteri</div>
                    </div>

                    <!-- Drawing Canvas -->
                    <div class="canvas-section">
                        <div class="section-title">‚úèÔ∏è Disegno / Grafico</div>
                        <div class="canvas-toolbar">
                            <div class="tool-group">
                                <button class="tool-btn active" id="toolPen" onclick="setTool('pen')" title="Penna">‚úèÔ∏è</button>
                                <button class="tool-btn" id="toolEraser" onclick="setTool('eraser')" title="Gomma">üßπ</button>
                                <button class="tool-btn" id="toolLine" onclick="setTool('line')" title="Linea">üìè</button>
                                <button class="tool-btn" id="toolRect" onclick="setTool('rect')" title="Rettangolo">‚¨ú</button>
                                <button class="tool-btn" id="toolCircle" onclick="setTool('circle')" title="Cerchio">‚≠ï</button>
                            </div>
                            <div class="tool-group">
                                <button class="color-btn active" style="background: #000000;" data-color="#000000" onclick="setColor('#000000')"></button>
                                <button class="color-btn" style="background: #ef4444;" data-color="#ef4444" onclick="setColor('#ef4444')"></button>
                                <button class="color-btn" style="background: #3b82f6;" data-color="#3b82f6" onclick="setColor('#3b82f6')"></button>
                                <button class="color-btn" style="background: #10b981;" data-color="#10b981" onclick="setColor('#10b981')"></button>
                                <button class="color-btn" style="background: #f59e0b;" data-color="#f59e0b" onclick="setColor('#f59e0b')"></button>
                                <button class="color-btn" style="background: #7c3aed;" data-color="#7c3aed" onclick="setColor('#7c3aed')"></button>
                            </div>
                            <div class="tool-group">
                                <span class="size-label" id="sizeLabel">3</span>
                                <input type="range" class="size-slider" id="sizeSlider" min="1" max="20" value="3" oninput="setSize(this.value)">
                            </div>
                            <div class="tool-group" style="margin-left: auto;">
                                <button class="tool-btn" onclick="undoDrawing()" title="Annulla">‚Ü©Ô∏è</button>
                                <button class="tool-btn danger" onclick="clearCanvas()" title="Cancella tutto">üóëÔ∏è</button>
                            </div>
                        </div>
                        <div class="canvas-wrapper" id="canvasWrapper">
                            <canvas id="drawingCanvas"></canvas>
                        </div>
                    </div>
                </div>
            </div>

            <!-- AI Analysis Tab -->
            <div class="tab-content" id="aiTab">
                <div class="stats-grid">
                    <div class="stat-card"><div class="stat-value" id="wordCount2">0</div><div class="stat-label">Parole</div></div>
                    <div class="stat-card"><div class="stat-value" id="speakerCount2">0</div><div class="stat-label">Speaker</div></div>
                </div>
                <div class="ai-section-title">üìù Elaborazione Testo</div>
                <div class="ai-actions">
                    <button class="ai-btn" onclick="runAI('correct')"><span class="ai-btn-icon">‚úèÔ∏è</span><span>Correggi</span><span class="ai-btn-label">Grammatica</span></button>
                    <button class="ai-btn" onclick="runAI('summary')"><span class="ai-btn-icon">üìù</span><span>Riassumi</span><span class="ai-btn-label">Sintesi</span></button>
                    <button class="ai-btn" onclick="runAI('keypoints')"><span class="ai-btn-icon">üéØ</span><span>Punti Chiave</span><span class="ai-btn-label">Elenco</span></button>
                    <button class="ai-btn" onclick="runAI('improve')"><span class="ai-btn-icon">üíé</span><span>Migliora</span><span class="ai-btn-label">Riscrittura</span></button>
                </div>
                <div class="ai-section-title">üîÄ Schemi Logici</div>
                <div class="ai-actions">
                    <button class="ai-btn schema-btn" onclick="runAI('flowchart')"><span class="ai-btn-icon">üîÄ</span><span>Flowchart</span><span class="ai-btn-label">Flusso processi</span></button>
                    <button class="ai-btn schema-btn" onclick="runAI('mindmap')"><span class="ai-btn-icon">üß†</span><span>Mappa</span><span class="ai-btn-label">Concetti</span></button>
                    <button class="ai-btn schema-btn" onclick="runAI('timeline')"><span class="ai-btn-icon">üìÖ</span><span>Timeline</span><span class="ai-btn-label">Cronologia</span></button>
                    <button class="ai-btn schema-btn" onclick="runAI('relations')"><span class="ai-btn-icon">üîó</span><span>Relazioni</span><span class="ai-btn-label">Connessioni</span></button>
                </div>
                <div class="ai-result" id="aiResult"><div class="ai-result-empty">Seleziona un'azione AI</div></div>
                <div class="mermaid-container" id="mermaidContainer" style="display: none;">
                    <div class="mermaid-header">
                        <span>üìä Schema Generato</span>
                        <button class="mermaid-copy-btn" onclick="copyMermaidCode()">üìã Copia Codice</button>
                    </div>
                    <div class="mermaid-render" id="mermaidRender"></div>
                    <details class="mermaid-code-details">
                        <summary>Mostra codice Mermaid</summary>
                        <pre class="mermaid-code" id="mermaidCode"></pre>
                    </details>
                </div>
            </div>

            <!-- Export Tab -->
            <div class="tab-content" id="exportTab">
                <div class="export-section">
                    <div class="export-card" onclick="exportPDF()"><div class="export-icon pdf">üìÑ</div><div class="export-info"><h3>Esporta PDF</h3><p>Tutto incluso</p></div></div>
                    <div class="export-card" onclick="exportTXT()"><div class="export-icon txt">üìù</div><div class="export-info"><h3>Esporta TXT</h3><p>Testo + Note</p></div></div>
                    <div class="export-card" onclick="exportAudio()"><div class="export-icon audio">üéµ</div><div class="export-info"><h3>Scarica Audio</h3><p>File registrato</p></div></div>
                    <div class="export-card" onclick="exportDrawing()"><div class="export-icon" style="background: rgba(245, 158, 11, 0.2);">üñºÔ∏è</div><div class="export-info"><h3>Scarica Disegno</h3><p>Immagine PNG</p></div></div>
                    <div class="export-card" onclick="saveSession()"><div class="export-icon" style="background: rgba(16, 185, 129, 0.2);">üíæ</div><div class="export-info"><h3>Salva Progetto</h3><p>Audio + Note + Disegno</p></div></div>
                </div>
            </div>

            <!-- Saved Tab -->
            <div class="tab-content" id="savedTab">
                <div class="retranscribe-section">
                    <button class="retranscribe-btn" onclick="loadAudioFile()"><span>üìÅ</span><span>Carica Audio da Trascrivere</span></button>
                    <p class="retranscribe-info">Supporta: .webm, .mp3, .wav, .m4a, .ogg (max ~25MB per parte)</p>
                </div>
                <div class="retranscribe-section" style="margin-top: 0.75rem; border-color: var(--accent);">
                    <button class="retranscribe-btn" style="background: linear-gradient(135deg, var(--accent) 0%, #059669 100%);" onclick="importProject()"><span>üì•</span><span>Importa Progetto (.json)</span></button>
                    <p class="retranscribe-info">Carica un progetto esportato precedentemente</p>
                </div>
                <div class="section-title" style="margin-top: 1rem;">üìÇ Progetti Salvati</div>
                <div class="recordings-list" id="recordingsList"></div>
            </div>
        </main>
    </div>

    <!-- Modals -->
    <div class="modal-overlay" id="saveModal">
        <div class="modal">
            <h2 class="modal-title">Salva Progetto</h2>
            <input type="text" class="modal-input" id="sessionNameInput" placeholder="Nome progetto">
            <div class="modal-buttons">
                <button class="modal-btn cancel" onclick="$('saveModal').classList.remove('active')">Annulla</button>
                <button class="modal-btn confirm" onclick="confirmSaveSession()">Salva</button>
            </div>
        </div>
    </div>

    <div class="modal-overlay" id="pdfModal">
        <div class="modal">
            <h2 class="modal-title">üìÑ Esporta PDF</h2>
            <input type="text" class="modal-input" id="pdfNameInput" placeholder="Nome documento">
            <div class="modal-checkboxes" style="margin-bottom: 1rem;">
                <label style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.85rem; margin-bottom: 0.5rem;">
                    <input type="checkbox" id="pdfIncludeTranscript" checked> Trascrizione
                </label>
                <label style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.85rem; margin-bottom: 0.5rem;">
                    <input type="checkbox" id="pdfIncludeNotes" checked> Note
                </label>
                <label style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.85rem; margin-bottom: 0.5rem;">
                    <input type="checkbox" id="pdfIncludeAI" checked> Analisi AI
                </label>
                <label style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.85rem; margin-bottom: 0.5rem;">
                    <input type="checkbox" id="pdfIncludeDrawing" checked> Disegno
                </label>
            </div>
            <div class="modal-buttons">
                <button class="modal-btn cancel" onclick="$('pdfModal').classList.remove('active')">Annulla</button>
                <button class="modal-btn confirm" onclick="confirmExportPDF()">Esporta</button>
            </div>
        </div>
    </div>

    <div class="modal-overlay" id="speakerModal">
        <div class="modal">
            <h2 class="modal-title">Nuovo Speaker</h2>
            <input type="text" class="modal-input" id="newSpeakerInput" placeholder="Nome">
            <div class="modal-buttons">
                <button class="modal-btn cancel" onclick="$('speakerModal').classList.remove('active')">Annulla</button>
                <button class="modal-btn confirm" onclick="confirmAddSpeaker()">Aggiungi</button>
            </div>
        </div>
    </div>

    <div class="toast" id="toast"></div>
    <audio id="keepAliveAudio" loop></audio>
    <input type="file" id="audioFileInput" accept="audio/*,.webm,.mp3,.wav,.m4a,.ogg">
    <input type="file" id="projectFileInput" accept=".json,application/json">

    <script>
        // ============ IndexedDB ============
        const DB_NAME = 'VoiceScribeDB';
        const DB_VERSION = 2;
        let db = null;

        async function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                request.onerror = () => reject(request.error);
                request.onsuccess = () => { db = request.result; resolve(db); };
                request.onupgradeneeded = (e) => {
                    const database = e.target.result;
                    if (!database.objectStoreNames.contains('audioChunks')) {
                        database.createObjectStore('audioChunks', { keyPath: 'id', autoIncrement: true });
                    }
                    if (!database.objectStoreNames.contains('savedAudio')) {
                        database.createObjectStore('savedAudio', { keyPath: 'sessionId' });
                    }
                    if (!database.objectStoreNames.contains('savedDrawings')) {
                        database.createObjectStore('savedDrawings', { keyPath: 'sessionId' });
                    }
                };
            });
        }

        async function saveChunkToDB(chunk, sessionId) {
            if (!db) await initDB();
            return new Promise((resolve, reject) => {
                const tx = db.transaction('audioChunks', 'readwrite');
                const store = tx.objectStore('audioChunks');
                const request = store.add({ sessionId, chunk, timestamp: Date.now() });
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        async function getChunksFromDB(sessionId) {
            if (!db) await initDB();
            return new Promise((resolve, reject) => {
                const tx = db.transaction('audioChunks', 'readonly');
                const store = tx.objectStore('audioChunks');
                const request = store.getAll();
                request.onsuccess = () => {
                    const all = request.result.filter(c => c.sessionId === sessionId);
                    all.sort((a, b) => a.timestamp - b.timestamp);
                    resolve(all);
                };
                request.onerror = () => reject(request.error);
            });
        }

        async function clearChunksFromDB(sessionId) {
            if (!db) await initDB();
            return new Promise((resolve, reject) => {
                const tx = db.transaction('audioChunks', 'readwrite');
                const store = tx.objectStore('audioChunks');
                const request = store.openCursor();
                request.onsuccess = (e) => {
                    const cursor = e.target.result;
                    if (cursor) {
                        if (cursor.value.sessionId === sessionId) cursor.delete();
                        cursor.continue();
                    } else resolve();
                };
                request.onerror = () => reject(request.error);
            });
        }

        async function saveSessionAudio(sessionId, audioBlob) {
            if (!db) await initDB();
            return new Promise((resolve, reject) => {
                const tx = db.transaction('savedAudio', 'readwrite');
                const store = tx.objectStore('savedAudio');
                const request = store.put({ sessionId, audio: audioBlob, timestamp: Date.now() });
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }

        async function getSessionAudio(sessionId) {
            if (!db) await initDB();
            return new Promise((resolve, reject) => {
                const tx = db.transaction('savedAudio', 'readonly');
                const store = tx.objectStore('savedAudio');
                const request = store.get(sessionId);
                request.onsuccess = () => resolve(request.result?.audio || null);
                request.onerror = () => reject(request.error);
            });
        }

        async function deleteSessionAudio(sessionId) {
            if (!db) await initDB();
            return new Promise((resolve, reject) => {
                const tx = db.transaction('savedAudio', 'readwrite');
                const store = tx.objectStore('savedAudio');
                const request = store.delete(sessionId);
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }

        async function saveSessionDrawing(sessionId, drawingDataUrl) {
            if (!db) await initDB();
            return new Promise((resolve, reject) => {
                const tx = db.transaction('savedDrawings', 'readwrite');
                const store = tx.objectStore('savedDrawings');
                const request = store.put({ sessionId, drawing: drawingDataUrl, timestamp: Date.now() });
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }

        async function getSessionDrawing(sessionId) {
            if (!db) await initDB();
            return new Promise((resolve, reject) => {
                const tx = db.transaction('savedDrawings', 'readonly');
                const store = tx.objectStore('savedDrawings');
                const request = store.get(sessionId);
                request.onsuccess = () => resolve(request.result?.drawing || null);
                request.onerror = () => reject(request.error);
            });
        }

        async function deleteSessionDrawing(sessionId) {
            if (!db) await initDB();
            return new Promise((resolve, reject) => {
                const tx = db.transaction('savedDrawings', 'readwrite');
                const store = tx.objectStore('savedDrawings');
                const request = store.delete(sessionId);
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }
    </script>

    <script>
        // ============ BACKGROUND MODE ============
        let bgAudioContext = null, bgOscillator = null, bgGain = null, bgInterval = null, notificationPermission = false;

        async function startAggressiveBackground() {
            if ('Notification' in window && Notification.permission === 'default') {
                const perm = await Notification.requestPermission();
                notificationPermission = perm === 'granted';
            } else notificationPermission = Notification.permission === 'granted';
            if (notificationPermission) new Notification('üéôÔ∏è VoiceScribe Registra', { body: 'Registrazione in corso...', tag: 'voicescribe-recording', requireInteraction: true, silent: true });
            try {
                bgAudioContext = new (window.AudioContext || window.webkitAudioContext)();
                if (bgAudioContext.state === 'suspended') await bgAudioContext.resume();
                bgOscillator = bgAudioContext.createOscillator();
                bgGain = bgAudioContext.createGain();
                bgOscillator.type = 'sine';
                bgOscillator.frequency.setValueAtTime(1, bgAudioContext.currentTime);
                bgGain.gain.setValueAtTime(0.001, bgAudioContext.currentTime);
                bgOscillator.connect(bgGain);
                bgGain.connect(bgAudioContext.destination);
                bgOscillator.start();
            } catch (e) {}
            bgInterval = setInterval(() => { if (bgAudioContext && bgAudioContext.state === 'suspended') bgAudioContext.resume(); }, 1000);
            const audio = $('keepAliveAudio'); audio.src = createToneDataURL(); audio.volume = 0.01; audio.play().catch(() => {});
            document.addEventListener('visibilitychange', handleVisibilityChange);
            if ('mediaSession' in navigator) { navigator.mediaSession.metadata = new MediaMetadata({ title: 'VoiceScribe', artist: 'Registrazione...', album: 'VoiceScribe Pro' }); navigator.mediaSession.playbackState = 'playing'; }
        }

        function stopAggressiveBackground() {
            if (bgOscillator) { try { bgOscillator.stop(); } catch(e) {} bgOscillator = null; }
            if (bgAudioContext) { bgAudioContext.close().catch(() => {}); bgAudioContext = null; }
            if (bgInterval) { clearInterval(bgInterval); bgInterval = null; }
            $('keepAliveAudio').pause(); $('keepAliveAudio').src = '';
            document.removeEventListener('visibilitychange', handleVisibilityChange);
        }

        function handleVisibilityChange() {
            if (document.visibilityState === 'visible') {
                if (isRecording && bgAudioContext) bgAudioContext.resume().catch(() => {});
                if (backgroundMode && 'wakeLock' in navigator) navigator.wakeLock.request('screen').then(wl => { wakeLock = wl; }).catch(() => {});
            }
        }

        function createToneDataURL() {
            const sampleRate = 8000, duration = 10, samples = sampleRate * duration;
            const buffer = new ArrayBuffer(44 + samples * 2);
            const view = new DataView(buffer);
            const writeString = (offset, string) => { for (let i = 0; i < string.length; i++) view.setUint8(offset + i, string.charCodeAt(i)); };
            writeString(0, 'RIFF'); view.setUint32(4, 36 + samples * 2, true); writeString(8, 'WAVE'); writeString(12, 'fmt ');
            view.setUint32(16, 16, true); view.setUint16(20, 1, true); view.setUint16(22, 1, true); view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * 2, true); view.setUint16(32, 2, true); view.setUint16(34, 16, true);
            writeString(36, 'data'); view.setUint32(40, samples * 2, true);
            for (let i = 0; i < samples; i++) { const t = i / sampleRate; view.setInt16(44 + i * 2, Math.sin(2 * Math.PI * 100 * t) * 0.01 * 32767, true); }
            return URL.createObjectURL(new Blob([buffer], { type: 'audio/wav' }));
        }
    </script>

    <script>
        // ============ DRAWING CANVAS ============
        let canvas, ctx;
        let currentTool = 'pen';
        let currentColor = '#000000';
        let currentSize = 3;
        let isDrawing = false;
        let lastX = 0, lastY = 0;
        let startX = 0, startY = 0;
        let drawingHistory = [];
        let currentPath = [];

        function initCanvas() {
            canvas = $('drawingCanvas');
            ctx = canvas.getContext('2d');
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // Mouse events
            canvas.addEventListener('mousedown', startDraw);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', endDraw);
            canvas.addEventListener('mouseout', endDraw);
            
            // Touch events
            canvas.addEventListener('touchstart', handleTouch);
            canvas.addEventListener('touchmove', handleTouch);
            canvas.addEventListener('touchend', endDraw);
            canvas.addEventListener('touchcancel', endDraw);
        }

        function resizeCanvas() {
            const wrapper = $('canvasWrapper');
            const rect = wrapper.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            
            // Save current drawing
            const imageData = canvas.width > 0 ? ctx.getImageData(0, 0, canvas.width, canvas.height) : null;
            
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            canvas.style.width = rect.width + 'px';
            canvas.style.height = rect.height + 'px';
            
            ctx.scale(dpr, dpr);
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            // Restore drawing
            if (imageData) {
                ctx.putImageData(imageData, 0, 0);
            } else {
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, rect.width, rect.height);
            }
            
            redrawFromHistory();
        }

        function getPos(e) {
            const rect = canvas.getBoundingClientRect();
            if (e.touches) {
                return { x: e.touches[0].clientX - rect.left, y: e.touches[0].clientY - rect.top };
            }
            return { x: e.clientX - rect.left, y: e.clientY - rect.top };
        }

        function handleTouch(e) {
            e.preventDefault();
            if (e.type === 'touchstart') startDraw(e);
            else if (e.type === 'touchmove') draw(e);
        }

        function startDraw(e) {
            isDrawing = true;
            const pos = getPos(e);
            lastX = pos.x;
            lastY = pos.y;
            startX = pos.x;
            startY = pos.y;
            
            if (currentTool === 'pen' || currentTool === 'eraser') {
                currentPath = [{ x: pos.x, y: pos.y }];
                ctx.beginPath();
                ctx.moveTo(pos.x, pos.y);
            }
        }

        function draw(e) {
            if (!isDrawing) return;
            const pos = getPos(e);
            
            if (currentTool === 'pen') {
                ctx.strokeStyle = currentColor;
                ctx.lineWidth = currentSize;
                ctx.lineTo(pos.x, pos.y);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(pos.x, pos.y);
                currentPath.push({ x: pos.x, y: pos.y });
            } else if (currentTool === 'eraser') {
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = currentSize * 3;
                ctx.lineTo(pos.x, pos.y);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(pos.x, pos.y);
                currentPath.push({ x: pos.x, y: pos.y });
            } else {
                // Shape tools - preview
                redrawFromHistory();
                ctx.strokeStyle = currentColor;
                ctx.lineWidth = currentSize;
                ctx.beginPath();
                
                if (currentTool === 'line') {
                    ctx.moveTo(startX, startY);
                    ctx.lineTo(pos.x, pos.y);
                } else if (currentTool === 'rect') {
                    ctx.rect(startX, startY, pos.x - startX, pos.y - startY);
                } else if (currentTool === 'circle') {
                    const rx = (pos.x - startX) / 2;
                    const ry = (pos.y - startY) / 2;
                    ctx.ellipse(startX + rx, startY + ry, Math.abs(rx), Math.abs(ry), 0, 0, Math.PI * 2);
                }
                ctx.stroke();
            }
            
            lastX = pos.x;
            lastY = pos.y;
        }

        function endDraw(e) {
            if (!isDrawing) return;
            isDrawing = false;
            
            if (currentTool === 'pen' || currentTool === 'eraser') {
                if (currentPath.length > 0) {
                    drawingHistory.push({
                        tool: currentTool,
                        color: currentTool === 'eraser' ? '#ffffff' : currentColor,
                        size: currentTool === 'eraser' ? currentSize * 3 : currentSize,
                        path: [...currentPath]
                    });
                }
            } else {
                const pos = e.changedTouches ? { x: e.changedTouches[0].clientX - canvas.getBoundingClientRect().left, y: e.changedTouches[0].clientY - canvas.getBoundingClientRect().top } : getPos(e);
                drawingHistory.push({
                    tool: currentTool,
                    color: currentColor,
                    size: currentSize,
                    start: { x: startX, y: startY },
                    end: pos
                });
            }
            currentPath = [];
        }

        function redrawFromHistory() {
            const wrapper = $('canvasWrapper');
            const rect = wrapper.getBoundingClientRect();
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, rect.width, rect.height);
            
            drawingHistory.forEach(item => {
                ctx.strokeStyle = item.color;
                ctx.lineWidth = item.size;
                ctx.beginPath();
                
                if (item.tool === 'pen' || item.tool === 'eraser') {
                    if (item.path && item.path.length > 0) {
                        ctx.moveTo(item.path[0].x, item.path[0].y);
                        item.path.forEach(p => ctx.lineTo(p.x, p.y));
                    }
                } else if (item.tool === 'line') {
                    ctx.moveTo(item.start.x, item.start.y);
                    ctx.lineTo(item.end.x, item.end.y);
                } else if (item.tool === 'rect') {
                    ctx.rect(item.start.x, item.start.y, item.end.x - item.start.x, item.end.y - item.start.y);
                } else if (item.tool === 'circle') {
                    const rx = (item.end.x - item.start.x) / 2;
                    const ry = (item.end.y - item.start.y) / 2;
                    ctx.ellipse(item.start.x + rx, item.start.y + ry, Math.abs(rx), Math.abs(ry), 0, 0, Math.PI * 2);
                }
                ctx.stroke();
            });
        }

        window.setTool = (tool) => {
            currentTool = tool;
            document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
            $(`tool${tool.charAt(0).toUpperCase() + tool.slice(1)}`).classList.add('active');
        };

        window.setColor = (color) => {
            currentColor = color;
            document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
            document.querySelector(`.color-btn[data-color="${color}"]`).classList.add('active');
        };

        window.setSize = (size) => {
            currentSize = parseInt(size);
            $('sizeLabel').textContent = size;
        };

        window.undoDrawing = () => {
            if (drawingHistory.length > 0) {
                drawingHistory.pop();
                redrawFromHistory();
                showToast('‚Ü©Ô∏è Annullato');
            }
        };

        window.clearCanvas = () => {
            if (drawingHistory.length === 0) return;
            if (confirm('Cancellare tutto il disegno?')) {
                drawingHistory = [];
                redrawFromHistory();
                showToast('üóëÔ∏è Canvas pulito');
            }
        };

        function getCanvasDataUrl() {
            return canvas.toDataURL('image/png');
        }

        function loadCanvasFromDataUrl(dataUrl) {
            const img = new Image();
            img.onload = () => {
                const wrapper = $('canvasWrapper');
                const rect = wrapper.getBoundingClientRect();
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, rect.width, rect.height);
                ctx.drawImage(img, 0, 0, rect.width, rect.height);
            };
            img.src = dataUrl;
        }
    </script>

    <script>
        // ============ MAIN APP ============
        let isRecording = false, isProcessing = false, isPaused = false, mediaRecorder = null, audioBlob = null;
        let recordedChunks = [];
        let transcriptEntries = [], speakers = ['Persona 1', 'Persona 2'], currentSpeaker = 1;
        let startTime = null, timerInterval = null, audioContext = null, analyser = null, animationId = null;
        let pausedTime = 0, pauseStartTime = null; // Per gestire la pausa
        let savedRecordings = JSON.parse(localStorage.getItem('voicescribe_recordings') || '[]');
        let whisperKey = localStorage.getItem('groq_whisper_key') || '';
        let llamaKey = localStorage.getItem('groq_llama_key') || '';
        let gemmaKey = localStorage.getItem('openrouter_gemma_key') || '';
        let selectedAiModel = localStorage.getItem('selected_ai_model') || 'gemma';
        let wakeLock = null, backgroundMode = false;
        const CHUNK_INTERVAL = 2 * 60 * 1000;
        let currentSessionId = null, chunkCount = 0, chunkTimer = null, currentStream = null;
        const $ = id => document.getElementById(id);

        // Notes
        let notesText = '';
        
        // AI Results storage
        let aiResults = {
            correct: null,
            summary: null,
            keypoints: null,
            improve: null,
            flowchart: null,
            mindmap: null,
            timeline: null,
            relations: null
        };

        async function init() {
            await initDB();
            if (whisperKey) { $('whisperKeyBox').style.display = 'none'; $('whisperKeySaved').style.display = 'flex'; }
            if (gemmaKey) { $('gemmaKeyBox').style.display = 'none'; $('gemmaKeySaved').style.display = 'flex'; }
            if (llamaKey) { $('llamaKeyBox').style.display = 'none'; $('llamaKeySaved').style.display = 'flex'; }
            
            // Setup AI model selector
            $('aiModelSelect').value = selectedAiModel;
            updateAiKeyVisibility();
            $('aiModelSelect').onchange = () => {
                selectedAiModel = $('aiModelSelect').value;
                localStorage.setItem('selected_ai_model', selectedAiModel);
                updateAiKeyVisibility();
            };
            
            checkAllKeysSaved();
            updateSpeakerChips(); renderSavedRecordings(); setupVisualizer(); setupEvents();
            initCanvas();
            checkRecoveredChunks();
            
            // Notes textarea handler
            $('notesTextarea').addEventListener('input', (e) => {
                notesText = e.target.value;
                $('notesCharCount').textContent = notesText.length;
            });
        }
        
        function updateAiKeyVisibility() {
            if (selectedAiModel === 'gemma') {
                $('gemmaKeyBox').style.display = gemmaKey ? 'none' : 'block';
                $('gemmaKeySaved').style.display = gemmaKey ? 'flex' : 'none';
                $('llamaKeyBox').style.display = 'none';
                $('llamaKeySaved').style.display = 'none';
            } else {
                $('llamaKeyBox').style.display = llamaKey ? 'none' : 'block';
                $('llamaKeySaved').style.display = llamaKey ? 'flex' : 'none';
                $('gemmaKeyBox').style.display = 'none';
                $('gemmaKeySaved').style.display = 'none';
            }
        }
        
        function checkAllKeysSaved() {
            const aiKeyOk = (selectedAiModel === 'gemma' && gemmaKey) || (selectedAiModel === 'llama' && llamaKey);
            if (whisperKey && aiKeyOk) $('saveKeysBtn').style.display = 'none';
            else $('saveKeysBtn').style.display = 'block';
        }

        async function checkRecoveredChunks() {
            try {
                const chunks = await getChunksFromDB('temp_recording');
                if (chunks.length > 0) {
                    if (confirm(`Trovati ${chunks.length} chunk audio. Recuperare?`)) {
                        await processRecoveredChunks(chunks);
                    } else await clearChunksFromDB('temp_recording');
                }
            } catch (e) {}
        }

        async function processRecoveredChunks(chunks) {
            showProgress(true, `Recupero ${chunks.length} chunk...`, 0);
            isProcessing = true; updateUI();
            for (let i = 0; i < chunks.length; i++) {
                showProgress(true, `Trascrivo chunk ${i + 1}/${chunks.length}...`, (i / chunks.length) * 100);
                try { const text = await transcribeBlob(chunks[i].chunk); if (text) addEntry(text); } catch (e) {}
            }
            audioBlob = new Blob(chunks.map(c => c.chunk), { type: chunks[0]?.chunk?.type || 'audio/webm' });
            await clearChunksFromDB('temp_recording');
            showProgress(false); isProcessing = false; updateUI();
            showToast(`‚úì Recuperati ${chunks.length} chunk`);
        }

        function setupVisualizer() {
            const v = $('visualizer');
            for (let i = 0; i < 10; i++) { const bar = document.createElement('div'); bar.className = 'visualizer-bar'; bar.style.height = '8px'; v.appendChild(bar); }
        }

        // API Keys
        $('saveKeysBtn').onclick = () => {
            const wk = $('whisperKeyInput').value.trim();
            const lk = $('llamaKeyInput').value.trim();
            const gk = $('gemmaKeyInput').value.trim();
            
            if (wk && wk.startsWith('gsk_')) { 
                whisperKey = wk; 
                localStorage.setItem('groq_whisper_key', wk); 
                $('whisperKeyBox').style.display = 'none'; 
                $('whisperKeySaved').style.display = 'flex'; 
            }
            if (lk && lk.startsWith('gsk_')) { 
                llamaKey = lk; 
                localStorage.setItem('groq_llama_key', lk); 
            }
            if (gk && gk.startsWith('sk-or-')) { 
                gemmaKey = gk; 
                localStorage.setItem('openrouter_gemma_key', gk); 
            }
            
            updateAiKeyVisibility();
            checkAllKeysSaved();
            showToast('‚úì Chiavi salvate');
        };

        window.changeKey = type => {
            if (type === 'whisper') { 
                $('whisperKeyBox').style.display = 'block'; 
                $('whisperKeySaved').style.display = 'none'; 
                $('whisperKeyInput').value = ''; 
            } else if (type === 'gemma') {
                $('gemmaKeyBox').style.display = 'block'; 
                $('gemmaKeySaved').style.display = 'none'; 
                $('gemmaKeyInput').value = '';
            } else { 
                $('llamaKeyBox').style.display = 'block'; 
                $('llamaKeySaved').style.display = 'none'; 
                $('llamaKeyInput').value = ''; 
            }
            $('saveKeysBtn').style.display = 'block';
        };

        // Background Mode
        async function enableBackgroundMode() {
            backgroundMode = true; $('bgBadge').style.display = 'flex'; $('bgWarning').classList.add('active');
            if ('wakeLock' in navigator) { try { wakeLock = await navigator.wakeLock.request('screen'); } catch (e) {} }
            await startAggressiveBackground();
            showToast('üîí Background attivo');
        }

        function disableBackgroundMode() {
            backgroundMode = false; $('bgBadge').style.display = 'none'; $('bgWarning').classList.remove('active');
            if (wakeLock) { wakeLock.release(); wakeLock = null; }
            stopAggressiveBackground();
        }

        // Speakers
        function updateSpeakerChips() {
            const c = $('speakerChips'); c.innerHTML = '';
            speakers.forEach((name, i) => {
                const chip = document.createElement('button');
                chip.className = `speaker-chip speaker-${i+1} ${i+1 === currentSpeaker ? 'active' : ''} ${isRecording && i+1 === currentSpeaker ? 'recording-active' : ''}`;
                chip.textContent = name; chip.onclick = () => { currentSpeaker = i+1; updateSpeakerChips(); if (isRecording) showToast(`üë§ ${name}`); };
                c.appendChild(chip);
            });
            const add = document.createElement('button'); add.className = 'speaker-chip add'; add.textContent = '+';
            add.onclick = () => $('speakerModal').classList.add('active'); c.appendChild(add);
        }

        window.confirmAddSpeaker = () => {
            const name = $('newSpeakerInput').value.trim();
            if (name && speakers.length < 5) { speakers.push(name); currentSpeaker = speakers.length; updateSpeakerChips(); $('speakerModal').classList.remove('active'); $('newSpeakerInput').value = ''; }
        };

        // ============ RECORDING ============
        async function startRecording() {
            if (!whisperKey) return showToast('‚ö†Ô∏è Inserisci chiave Whisper');
            if ($('backgroundToggle').checked) {
                if ('Notification' in window && Notification.permission === 'default') await Notification.requestPermission();
                showToast('üîä Tieni volume alto!');
                await new Promise(r => setTimeout(r, 1000));
            }
            try {
                currentStream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: true, noiseSuppression: true, sampleRate: 16000 } });
                if ($('backgroundToggle').checked) await enableBackgroundMode();
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                audioContext.createMediaStreamSource(currentStream).connect(analyser);
                analyser.fftSize = 256;
                currentSessionId = 'temp_recording'; chunkCount = 0; recordedChunks = [];
                isPaused = false; pausedTime = 0; pauseStartTime = null; // Reset pausa
                startNewChunk();
                chunkTimer = setInterval(() => { if (isRecording && !isPaused) rotateChunk(); }, CHUNK_INTERVAL);
                isRecording = true; startTime = Date.now(); updateUI(); updateSpeakerChips(); startTimer(); startVisualizer();
            } catch (e) { showToast('‚ö†Ô∏è ' + e.message); }
        }

        function startNewChunk() {
            const mime = MediaRecorder.isTypeSupported('audio/webm;codecs=opus') ? 'audio/webm;codecs=opus' : 'audio/webm';
            mediaRecorder = new MediaRecorder(currentStream, { mimeType: mime });
            let chunkData = [];
            mediaRecorder.ondataavailable = e => { if (e.data.size > 0) chunkData.push(e.data); };
            mediaRecorder.onstop = async () => {
                if (chunkData.length > 0) {
                    const chunkBlob = new Blob(chunkData, { type: mime });
                    recordedChunks.push(chunkBlob);
                    try { await saveChunkToDB(chunkBlob, currentSessionId); } catch (e) {}
                }
            };
            mediaRecorder.start(1000);
            chunkCount++;
            $('chunkIndicator').textContent = `Chunk: ${chunkCount}`;
            $('chunkIndicator').classList.add('active');
        }

        async function rotateChunk() {
            if (!mediaRecorder || mediaRecorder.state === 'inactive' || isPaused) return;
            mediaRecorder.stop();
            await new Promise(r => setTimeout(r, 100));
            startNewChunk();
            showToast(`üì¶ Chunk ${chunkCount} salvato`);
        }

        async function stopRecording() {
            if (!isRecording) return;
            if (chunkTimer) { clearInterval(chunkTimer); chunkTimer = null; }
            isRecording = false; isProcessing = true; isPaused = false;
            if (mediaRecorder?.state !== 'inactive') { mediaRecorder.stop(); await new Promise(r => setTimeout(r, 200)); }
            if (currentStream) { currentStream.getTracks().forEach(t => t.stop()); currentStream = null; }
            if (animationId) cancelAnimationFrame(animationId);
            if (audioContext) audioContext.close().catch(() => {});
            clearInterval(timerInterval);
            if (backgroundMode) disableBackgroundMode();
            updateUI(); updateSpeakerChips();
            $('chunkIndicator').classList.remove('active');
            await processAllChunks();
        }

        // ============ PAUSE FUNCTIONALITY ============
        window.togglePause = () => {
            if (!isRecording || isProcessing) return;
            
            if (isPaused) {
                // Resume
                isPaused = false;
                pausedTime += Date.now() - pauseStartTime;
                pauseStartTime = null;
                
                if (mediaRecorder && mediaRecorder.state === 'paused') {
                    mediaRecorder.resume();
                }
                
                // Resume chunk timer
                if (!chunkTimer) {
                    chunkTimer = setInterval(() => { if (isRecording && !isPaused) rotateChunk(); }, CHUNK_INTERVAL);
                }
                
                showToast('‚ñ∂Ô∏è Ripreso');
            } else {
                // Pause
                isPaused = true;
                pauseStartTime = Date.now();
                
                if (mediaRecorder && mediaRecorder.state === 'recording') {
                    mediaRecorder.pause();
                }
                
                // Pause chunk timer
                if (chunkTimer) {
                    clearInterval(chunkTimer);
                    chunkTimer = null;
                }
                
                showToast('‚è∏Ô∏è In pausa');
            }
            
            updateUI();
        };

        async function processAllChunks() {
            if (recordedChunks.length === 0) { isProcessing = false; updateUI(); return; }
            showProgress(true, `Trascrivo ${recordedChunks.length} chunk...`, 0);
            let allText = '', successCount = 0, errorCount = 0;
            for (let i = 0; i < recordedChunks.length; i++) {
                showProgress(true, `Trascrivo chunk ${i + 1}/${recordedChunks.length}...`, ((i) / recordedChunks.length) * 100);
                try { const text = await transcribeBlob(recordedChunks[i]); if (text) { allText += (allText ? ' ' : '') + text; successCount++; } } catch (e) { errorCount++; }
            }
            if (recordedChunks.length > 0) audioBlob = new Blob(recordedChunks, { type: recordedChunks[0].type });
            if (allText) addEntry(allText);
            await clearChunksFromDB('temp_recording');
            showProgress(false); isProcessing = false; updateUI();
            $('recordHint').textContent = 'Tocca per registrare';
            showToast(errorCount > 0 ? `‚ö†Ô∏è ${successCount} OK, ${errorCount} errori` : `‚úì ${successCount} chunk trascritti`);
        }

        async function transcribeBlob(blob) {
            const form = new FormData();
            form.append('file', blob, 'audio.webm');
            form.append('model', 'whisper-large-v3');
            form.append('language', $('languageSelect').value);
            const res = await fetch('https://api.groq.com/openai/v1/audio/transcriptions', { method: 'POST', headers: { 'Authorization': `Bearer ${whisperKey}` }, body: form });
            const data = await res.json();
            if (!res.ok) throw new Error(data.error?.message || `Errore ${res.status}`);
            return data.text?.trim() || '';
        }

        function showProgress(show, title = '', percent = 0) {
            const section = $('progressSection');
            if (show) { section.classList.add('active'); $('progressTitle').textContent = title; $('progressFill').style.width = `${percent}%`; $('progressText').textContent = `${Math.round(percent)}%`; }
            else section.classList.remove('active');
        }

        // Load audio file
        window.loadAudioFile = () => $('audioFileInput').click();
        
        // Split audio file into chunks using Web Audio API
        async function splitAudioFile(file, chunkDurationMs = 120000) { // 2 minuti per chunk
            return new Promise(async (resolve, reject) => {
                try {
                    const arrayBuffer = await file.arrayBuffer();
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                    
                    const sampleRate = audioBuffer.sampleRate;
                    const numberOfChannels = audioBuffer.numberOfChannels;
                    const totalDuration = audioBuffer.duration * 1000; // in ms
                    
                    const chunks = [];
                    let startMs = 0;
                    
                    while (startMs < totalDuration) {
                        const endMs = Math.min(startMs + chunkDurationMs, totalDuration);
                        const startSample = Math.floor((startMs / 1000) * sampleRate);
                        const endSample = Math.floor((endMs / 1000) * sampleRate);
                        const frameCount = endSample - startSample;
                        
                        // Create offline context for this chunk
                        const offlineContext = new OfflineAudioContext(numberOfChannels, frameCount, sampleRate);
                        const chunkBuffer = offlineContext.createBuffer(numberOfChannels, frameCount, sampleRate);
                        
                        // Copy audio data
                        for (let channel = 0; channel < numberOfChannels; channel++) {
                            const sourceData = audioBuffer.getChannelData(channel);
                            const destData = chunkBuffer.getChannelData(channel);
                            for (let i = 0; i < frameCount; i++) {
                                destData[i] = sourceData[startSample + i] || 0;
                            }
                        }
                        
                        // Convert to WAV blob
                        const wavBlob = await audioBufferToWav(chunkBuffer);
                        chunks.push(wavBlob);
                        
                        startMs = endMs;
                    }
                    
                    audioContext.close();
                    resolve(chunks);
                } catch (err) {
                    reject(err);
                }
            });
        }
        
        // Convert AudioBuffer to WAV Blob
        function audioBufferToWav(buffer) {
            const numChannels = buffer.numberOfChannels;
            const sampleRate = buffer.sampleRate;
            const format = 1; // PCM
            const bitDepth = 16;
            
            const bytesPerSample = bitDepth / 8;
            const blockAlign = numChannels * bytesPerSample;
            
            const dataLength = buffer.length * blockAlign;
            const bufferLength = 44 + dataLength;
            
            const arrayBuffer = new ArrayBuffer(bufferLength);
            const view = new DataView(arrayBuffer);
            
            // WAV header
            const writeString = (offset, string) => {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            };
            
            writeString(0, 'RIFF');
            view.setUint32(4, bufferLength - 8, true);
            writeString(8, 'WAVE');
            writeString(12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, format, true);
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * blockAlign, true);
            view.setUint16(32, blockAlign, true);
            view.setUint16(34, bitDepth, true);
            writeString(36, 'data');
            view.setUint32(40, dataLength, true);
            
            // Write audio data
            let offset = 44;
            for (let i = 0; i < buffer.length; i++) {
                for (let channel = 0; channel < numChannels; channel++) {
                    const sample = Math.max(-1, Math.min(1, buffer.getChannelData(channel)[i]));
                    const intSample = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
                    view.setInt16(offset, intSample, true);
                    offset += 2;
                }
            }
            
            return new Blob([arrayBuffer], { type: 'audio/wav' });
        }
        
        $('audioFileInput').onchange = async (e) => {
            const file = e.target.files[0]; if (!file) return;
            if (!whisperKey) { showToast('‚ö†Ô∏è Inserisci chiave Whisper'); return; }
            
            const fileSizeMB = file.size / (1024 * 1024);
            showToast(`üìÅ ${file.name} (${fileSizeMB.toFixed(1)}MB)`);
            
            isProcessing = true; updateUI();
            
            try {
                // Se il file √® piccolo (< 20MB), trascrivi direttamente
                if (fileSizeMB < 20) {
                    showProgress(true, 'Trascrivo audio...', 30);
                    const text = await transcribeBlob(file);
                    if (text) { 
                        addEntry(text); 
                        showToast('‚úì Trascrizione completata'); 
                    } else {
                        showToast('‚ö†Ô∏è Nessun testo rilevato');
                    }
                } else {
                    // File grande: dividi in chunk
                    showProgress(true, 'Divido audio in parti...', 10);
                    
                    let chunks;
                    try {
                        chunks = await splitAudioFile(file);
                        showToast(`üìä Diviso in ${chunks.length} parti`);
                    } catch (splitErr) {
                        // Fallback: prova a inviare direttamente
                        console.error('Split failed:', splitErr);
                        showProgress(true, 'Trascrivo audio...', 30);
                        const text = await transcribeBlob(file);
                        if (text) { 
                            addEntry(text); 
                            showToast('‚úì Trascrizione completata'); 
                        }
                        throw new Error('stop'); // Skip rest
                    }
                    
                    // Trascrivi ogni chunk
                    let allText = '';
                    for (let i = 0; i < chunks.length; i++) {
                        const progress = 20 + (i / chunks.length) * 70;
                        showProgress(true, `Trascrivo parte ${i + 1}/${chunks.length}...`, progress);
                        
                        try {
                            const text = await transcribeBlob(chunks[i]);
                            if (text) allText += (allText ? ' ' : '') + text;
                        } catch (chunkErr) {
                            console.error(`Chunk ${i + 1} error:`, chunkErr);
                        }
                    }
                    
                    if (allText) {
                        addEntry(allText);
                        showToast(`‚úì Trascritte ${chunks.length} parti`);
                    } else {
                        showToast('‚ö†Ô∏è Nessun testo rilevato');
                    }
                }
                
                audioBlob = file;
            } catch (err) {
                if (err.message !== 'stop') {
                    console.error('Transcription error:', err);
                    showToast('‚ö†Ô∏è ' + (err.message || 'Errore trascrizione'));
                }
            }
            
            showProgress(false); 
            isProcessing = false; 
            updateUI();
            e.target.value = '';
        };

        // AI Analysis
        let lastMermaidCode = '';
        
        // Funzione per pulire il codice Mermaid
        function cleanMermaidCode(content) {
            let code = content
                .replace(/```mermaid\n?/gi, '')
                .replace(/```\n?/g, '')
                .replace(/^\s*[\r\n]/gm, '\n')
                .trim();
            
            // Trova l'inizio del codice Mermaid valido
            const lines = code.split('\n');
            const validStarts = ['flowchart', 'graph', 'mindmap', 'timeline', 'erdiagram', 'sequencediagram', 'pie', 'gantt'];
            const startIdx = lines.findIndex(l => validStarts.some(s => l.trim().toLowerCase().startsWith(s)));
            
            if (startIdx > 0) {
                code = lines.slice(startIdx).join('\n');
            } else if (startIdx === -1) {
                // Se non trova un inizio valido, crea un flowchart semplice
                code = 'flowchart TD\n    A[Contenuto] --> B[Da elaborare]';
            }
            
            // Pulizia caratteri problematici
            code = code
                .replace(/[""‚Äû]/g, '"')
                .replace(/[''‚Äö]/g, "'")
                .replace(/‚Ä¶/g, '...')
                .replace(/[‚Äì‚Äî]/g, '-')
                .replace(/\t/g, '    ')
                // Rimuovi emoji
                .replace(/[\u{1F600}-\u{1F64F}]/gu, '')
                .replace(/[\u{1F300}-\u{1F5FF}]/gu, '')
                .replace(/[\u{1F680}-\u{1F6FF}]/gu, '')
                .replace(/[\u{2600}-\u{26FF}]/gu, '')
                .replace(/[\u{2700}-\u{27BF}]/gu, '')
                // Converti accenti comuni
                .replace(/[√†√°√¢√£√§√•]/g, 'a')
                .replace(/[√®√©√™√´]/g, 'e')
                .replace(/[√¨√≠√Æ√Ø]/g, 'i')
                .replace(/[√≤√≥√¥√µ√∂]/g, 'o')
                .replace(/[√π√∫√ª√º]/g, 'u')
                .replace(/[√Ä√Å√Ç√É√Ñ√Ö]/g, 'A')
                .replace(/[√à√â√ä√ã]/g, 'E')
                .replace(/[√å√ç√é√è]/g, 'I')
                .replace(/[√í√ì√î√ï√ñ]/g, 'O')
                .replace(/[√ô√ö√õ√ú]/g, 'U')
                .replace(/√±/g, 'n')
                .replace(/√ë/g, 'N')
                .replace(/√ß/g, 'c')
                .replace(/√á/g, 'C');
            
            // Pulisci le linee
            code = code.split('\n').map(line => {
                // Rimuovi caratteri problematici dentro parentesi
                return line
                    .replace(/\[([^\]]+)\]/g, (match, text) => {
                        const clean = text.replace(/[<>&]/g, '').trim();
                        return `[${clean || 'Nodo'}]`;
                    })
                    .replace(/\(([^)]+)\)/g, (match, text) => {
                        const clean = text.replace(/[<>&]/g, '').trim();
                        return `(${clean || 'Nodo'})`;
                    })
                    .replace(/\{([^}]+)\}/g, (match, text) => {
                        const clean = text.replace(/[<>&]/g, '').trim();
                        return `{${clean || 'Decisione'}}`;
                    });
            }).join('\n');
            
            // Rimuovi righe vuote multiple
            code = code.replace(/\n{3,}/g, '\n\n');
            
            return code.trim();
        }
        
        // Funzione per renderizzare Mermaid
        async function renderMermaidDiagram(code, title) {
            const renderDiv = $('mermaidRender');
            const container = $('mermaidContainer');
            
            $('aiResult').innerHTML = `<div class="ai-result-title">${title}</div><div class="ai-result-content">‚è≥ Generazione schema...</div>`;
            
            try {
                // Crea un ID univoco
                const id = 'mermaid-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
                
                // Prova a renderizzare
                const { svg } = await mermaid.render(id, code);
                
                renderDiv.innerHTML = svg;
                container.style.display = 'block';
                $('aiResult').innerHTML = `<div class="ai-result-title">${title}</div><div class="ai-result-content">‚úÖ Schema generato con successo!</div>`;
                
                // Restituisci l'SVG per salvarlo
                return svg;
            } catch (err) {
                console.warn('Mermaid render error:', err);
                
                // Mostra il codice come fallback
                renderDiv.innerHTML = `
                    <div style="padding: 1rem; background: #f5f5f5; border-radius: 8px;">
                        <p style="color: #e74c3c; margin-bottom: 0.5rem; font-weight: bold;">‚ö†Ô∏è Errore rendering diagramma</p>
                        <p style="color: #666; font-size: 0.8rem; margin-bottom: 1rem;">Il codice generato potrebbe avere errori di sintassi. Puoi copiarlo e correggerlo manualmente.</p>
                        <pre style="background: #fff; padding: 0.75rem; border-radius: 4px; font-size: 0.75rem; overflow-x: auto; white-space: pre-wrap;">${escapeHtml(code)}</pre>
                    </div>`;
                container.style.display = 'block';
                $('aiResult').innerHTML = `<div class="ai-result-title">${title}</div><div class="ai-result-content">‚ö†Ô∏è Schema generato ma con errori di rendering. Vedi sotto per il codice.</div>`;
                
                return null;
            }
        }
        
        // Escape HTML per sicurezza
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        window.runAI = async (action) => {
            // Check appropriate key based on selected model
            if (selectedAiModel === 'gemma' && !gemmaKey) return showToast('‚ö†Ô∏è Inserisci chiave OpenRouter');
            if (selectedAiModel === 'llama' && !llamaKey) return showToast('‚ö†Ô∏è Inserisci chiave Groq');
            
            const transcriptText = transcriptEntries.map(e => `${e.speakerName}: ${e.text}`).join('\n');
            const fullText = transcriptText + (notesText ? '\n\nNOTE:\n' + notesText : '');
            if (!fullText.trim()) return showToast('‚ö†Ô∏è Nessun contenuto');
            
            const isSchema = ['flowchart', 'mindmap', 'timeline', 'relations'].includes(action);
            
            const prompts = {
                correct: `Correggi gli errori grammaticali nel seguente testo:\n\n${fullText}`,
                summary: `Riassumi:\n\n${fullText}`,
                keypoints: `Estrai i punti chiave:\n\n${fullText}`,
                improve: `Riscrivi in modo pi√π chiaro e professionale:\n\n${fullText}`,
                flowchart: `Crea un flowchart Mermaid dal testo. Regole STRETTE:
- Inizia SOLO con: flowchart TD
- Usa ID semplici: A, B, C, D (senza spazi)
- Testo nodi tra parentesi quadre: A[Testo breve]
- Frecce: A --> B oppure A -->|label| B
- NO caratteri speciali, NO emoji, NO accenti
- Max 3-4 parole per nodo

Esempio corretto:
flowchart TD
    A[Inizio] --> B[Processo]
    B --> C{Decisione}
    C -->|Si| D[Fine]
    C -->|No| B

Testo: ${fullText}

Rispondi SOLO con il codice Mermaid, niente altro:`,
                mindmap: `Crea una mindmap Mermaid dal testo. Regole STRETTE:
- Inizia SOLO con: mindmap
- Seconda riga: root((Tema centrale))
- Indenta con spazi per sottocategorie
- NO caratteri speciali, NO emoji
- Testo breve per ogni nodo

Esempio corretto:
mindmap
    root((Argomento))
        Categoria 1
            Elemento A
            Elemento B
        Categoria 2
            Elemento C

Testo: ${fullText}

Rispondi SOLO con il codice Mermaid, niente altro:`,
                timeline: `Crea una timeline Mermaid dal testo. Regole STRETTE:
- Inizia SOLO con: timeline
- Seconda riga: title Titolo
- Formato: sezione : evento
- NO caratteri speciali, NO emoji

Esempio corretto:
timeline
    title Cronologia
    Fase 1 : Evento iniziale
    Fase 2 : Sviluppo
    Fase 3 : Conclusione

Testo: ${fullText}

Rispondi SOLO con il codice Mermaid, niente altro:`,
                relations: `Crea un diagramma relazioni Mermaid dal testo. Regole STRETTE:
- Inizia SOLO con: graph TD
- ID semplici: A, B, C
- Testo tra parentesi quadre: A[Nome]
- Connessioni: A --> B oppure A --- B
- Label su frecce: A -->|relazione| B
- NO caratteri speciali, NO emoji

Esempio corretto:
graph TD
    A[Persona 1] -->|conosce| B[Persona 2]
    B -->|lavora con| C[Persona 3]
    A --- C

Testo: ${fullText}

Rispondi SOLO con il codice Mermaid, niente altro:`
            };
            
            const titles = { 
                correct: '‚úèÔ∏è Corretto', 
                summary: 'üìù Riassunto', 
                keypoints: 'üéØ Punti Chiave', 
                improve: 'üíé Migliorato',
                flowchart: 'üîÄ Flowchart',
                mindmap: 'üß† Mappa Concettuale',
                timeline: 'üìÖ Timeline',
                relations: 'üîó Diagramma Relazioni'
            };
            
            document.querySelectorAll('.ai-btn').forEach(btn => btn.classList.add('processing'));
            $('aiResult').innerHTML = `<div class="ai-result-empty">‚è≥ ${isSchema ? 'Generazione schema' : 'Elaborazione'} con ${selectedAiModel === 'gemma' ? 'Gemma 3' : 'Llama'}...</div>`;
            $('mermaidContainer').style.display = 'none';
            
            try {
                let res, data;
                
                if (selectedAiModel === 'gemma') {
                    res = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                        method: 'POST', 
                        headers: { 
                            'Authorization': `Bearer ${gemmaKey}`, 
                            'Content-Type': 'application/json',
                            'HTTP-Referer': window.location.href,
                            'X-Title': 'VoiceScribe Pro'
                        },
                        body: JSON.stringify({ 
                            model: 'google/gemma-3-27b-it:free', 
                            messages: [{ role: 'user', content: prompts[action] }], 
                            max_tokens: 2048, 
                            temperature: isSchema ? 0.2 : 0.3 
                        })
                    });
                } else {
                    res = await fetch('https://api.groq.com/openai/v1/chat/completions', {
                        method: 'POST', 
                        headers: { 
                            'Authorization': `Bearer ${llamaKey}`, 
                            'Content-Type': 'application/json' 
                        },
                        body: JSON.stringify({ 
                            model: 'llama-3.1-8b-instant', 
                            messages: [{ role: 'user', content: prompts[action] }], 
                            max_tokens: 2048, 
                            temperature: isSchema ? 0.2 : 0.3 
                        })
                    });
                }
                
                data = await res.json();
                if (!res.ok) throw new Error(data.error?.message || data.error || 'Errore');
                
                const content = data.choices?.[0]?.message?.content || '';
                
                if (isSchema) {
                    // Parse e pulisci codice Mermaid
                    let mermaidCode = cleanMermaidCode(content);
                    
                    lastMermaidCode = mermaidCode;
                    $('mermaidCode').textContent = mermaidCode;
                    
                    // Salva il risultato (SVG verr√† aggiunto dopo il render)
                    aiResults[action] = { type: 'schema', code: mermaidCode, title: titles[action], svg: null };
                    
                    // Render Mermaid e salva SVG
                    const svg = await renderMermaidDiagram(mermaidCode, titles[action]);
                    if (svg) {
                        aiResults[action].svg = svg;
                    }
                } else {
                    $('aiResult').innerHTML = `<div class="ai-result-title">${titles[action]}</div><div class="ai-result-content">${content || 'Nessun risultato'}</div>`;
                    // Salva il risultato
                    aiResults[action] = { type: 'text', content: content, title: titles[action] };
                    $('mermaidContainer').style.display = 'none';
                }
            } catch (e) { 
                $('aiResult').innerHTML = `<div class="ai-result-empty">‚ö†Ô∏è ${e.message}</div>`; 
            }
            document.querySelectorAll('.ai-btn').forEach(btn => btn.classList.remove('processing'));
        };
        
        window.copyMermaidCode = () => {
            if (lastMermaidCode) {
                navigator.clipboard.writeText(lastMermaidCode).then(() => {
                    showToast('üìã Codice copiato!');
                }).catch(() => {
                    showToast('‚ö†Ô∏è Errore copia');
                });
            }
        };

        // UI
        function updateUI() {
            const btn = $('recordBtn'), cont = $('recordBtnContainer'), icon = $('recordIcon');
            const pauseBtn = $('pauseBtn'), pauseIcon = $('pauseIcon'), timer = $('timer');
            
            btn.classList.remove('recording', 'processing', 'paused'); 
            cont.classList.remove('recording');
            pauseBtn.classList.remove('visible', 'paused');
            timer.classList.remove('paused');
            
            if (isProcessing) {
                btn.classList.add('processing');
                icon.innerHTML = '<circle cx="12" cy="12" r="3"/><circle cx="12" cy="12" r="6" fill="none" stroke="white" stroke-width="2" stroke-dasharray="20"><animateTransform attributeName="transform" type="rotate" from="0 12 12" to="360 12 12" dur="1s" repeatCount="indefinite"/></circle>';
                setStatus('processing', 'Elaboro...'); 
                $('visualizer').style.display = 'none';
            } else if (isRecording) {
                cont.classList.add('recording');
                pauseBtn.classList.add('visible');
                
                if (isPaused) {
                    btn.classList.add('paused');
                    pauseBtn.classList.add('paused');
                    timer.classList.add('paused');
                    icon.innerHTML = '<rect x="6" y="6" width="12" height="12" rx="2"/>';
                    // Play icon for pause button (to resume)
                    pauseIcon.innerHTML = '<path d="M8 5v14l11-7z"/>';
                    setStatus('paused', 'PAUSA');
                    $('visualizer').style.display = 'none';
                    $('recordHint').textContent = 'In pausa - tocca ‚ñ∂Ô∏è per riprendere';
                } else {
                    btn.classList.add('recording');
                    icon.innerHTML = '<rect x="6" y="6" width="12" height="12" rx="2"/>';
                    // Pause icon
                    pauseIcon.innerHTML = '<rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/>';
                    setStatus('recording', 'REC'); 
                    $('visualizer').style.display = 'flex';
                    $('recordHint').textContent = 'Registrazione in corso...';
                }
            } else {
                icon.innerHTML = '<path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3z"/><path d="M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z"/>';
                setStatus('idle', 'Pronto'); 
                $('visualizer').style.display = 'none';
                $('recordHint').textContent = 'Tocca per registrare';
            }
        }

        function setStatus(type, text) { $('statusBadge').className = `status-badge ${type}`; $('statusText').textContent = text; }

        function startTimer() {
            timerInterval = setInterval(() => {
                if (isPaused) return; // Non aggiornare durante la pausa
                const elapsed = Date.now() - startTime - pausedTime;
                const s = Math.floor(elapsed / 1000);
                $('timer').textContent = `${String(Math.floor(s/60)).padStart(2,'0')}:${String(s%60).padStart(2,'0')}`;
            }, 1000);
        }

        function startVisualizer() {
            const bars = $('visualizer').querySelectorAll('.visualizer-bar');
            (function animate() {
                if (!isRecording || !analyser) return;
                const data = new Uint8Array(analyser.frequencyBinCount); analyser.getByteFrequencyData(data);
                bars.forEach((bar, i) => { bar.style.height = `${Math.max(8, (data[i*4]/255)*40)}px`; });
                animationId = requestAnimationFrame(animate);
            })();
        }

        // Transcript
        function addEntry(text) {
            const entry = { speaker: currentSpeaker, speakerName: speakers[currentSpeaker-1], text, time: $('timer').textContent, timestamp: Date.now() };
            transcriptEntries.push(entry); renderEntry(entry); updateStats();
        }

        function renderEntry(entry) {
            $('emptyState').style.display = 'none';
            const div = document.createElement('div'); div.className = 'transcript-entry';
            div.innerHTML = `<div class="transcript-speaker"><span class="speaker-label label-speaker-${entry.speaker}">${entry.speakerName}</span><span class="transcript-time">${entry.time}</span></div><p class="transcript-text">${entry.text}</p>`;
            $('transcriptArea').appendChild(div); $('transcriptArea').scrollTop = $('transcriptArea').scrollHeight;
        }

        function updateStats() {
            $('transcriptCount').textContent = `${transcriptEntries.length} frasi`;
            const text = transcriptEntries.map(e => e.text).join(' '), words = text.split(/\s+/).filter(w => w);
            $('wordCount2').textContent = words.length;
            const sw = {}; transcriptEntries.forEach(e => { sw[e.speakerName] = (sw[e.speakerName]||0) + e.text.split(/\s+/).length; });
            $('speakerCount2').textContent = Object.keys(sw).length;
        }

        function renderAllEntries() {
            $('transcriptArea').innerHTML = '';
            if (!transcriptEntries.length) {
                const e = document.createElement('div'); e.className = 'empty-state'; e.id = 'emptyState';
                e.innerHTML = '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3z"/><path d="M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z"/></svg><p>Tocca per registrare</p>';
                $('transcriptArea').appendChild(e);
            } else transcriptEntries.forEach(renderEntry);
            updateStats();
        }

        // Export
        window.exportPDF = () => {
            if (!transcriptEntries.length && !notesText && drawingHistory.length === 0 && !Object.values(aiResults).some(r => r !== null)) {
                return showToast('Nessun contenuto');
            }
            $('pdfNameInput').value = `VoiceScribe_${new Date().toLocaleDateString('it-IT').replace(/\//g, '-')}`;
            $('pdfIncludeTranscript').checked = transcriptEntries.length > 0;
            $('pdfIncludeNotes').checked = !!notesText;
            $('pdfIncludeAI').checked = Object.values(aiResults).some(r => r !== null);
            $('pdfIncludeDrawing').checked = drawingHistory.length > 0;
            $('pdfModal').classList.add('active');
        };
        
        window.confirmExportPDF = async () => {
            const pdfName = $('pdfNameInput').value.trim() || 'VoiceScribe';
            const includeTranscript = $('pdfIncludeTranscript').checked;
            const includeNotes = $('pdfIncludeNotes').checked;
            const includeAI = $('pdfIncludeAI').checked;
            const includeDrawing = $('pdfIncludeDrawing').checked;
            
            $('pdfModal').classList.remove('active');
            showToast('‚è≥ Generazione PDF...');
            
            // Piccolo delay per mostrare il toast
            await new Promise(r => setTimeout(r, 100));
            
            const { jsPDF } = window.jspdf, doc = new jsPDF();
            doc.setFontSize(20); doc.setTextColor(0,212,170); doc.text(pdfName, 20, 25);
            doc.setFontSize(10); doc.setTextColor(100); doc.text(`${new Date().toLocaleDateString('it-IT')} - ${$('timer').textContent}`, 20, 32);
            doc.line(20,36,190,36); let y = 45; doc.setFontSize(9);
            
            // Transcript
            if (includeTranscript && transcriptEntries.length) {
                doc.setFontSize(12); doc.setTextColor(0,150,120); doc.text('TRASCRIZIONE', 20, y); y += 8;
                doc.setFontSize(9);
                transcriptEntries.forEach(e => {
                    if (y > 270) { doc.addPage(); y = 20; }
                    doc.setTextColor(0,150,120); doc.text(`[${e.time}] ${e.speakerName}:`, 20, y); y += 5;
                    doc.setTextColor(0); doc.splitTextToSize(e.text, 165).forEach(l => { if (y > 270) { doc.addPage(); y = 20; } doc.text(l, 25, y); y += 4; }); y += 3;
                });
            }
            
            // Notes
            if (includeNotes && notesText) {
                y += 5; if (y > 250) { doc.addPage(); y = 20; }
                doc.setFontSize(12); doc.setTextColor(0,150,120); doc.text('NOTE', 20, y); y += 8;
                doc.setFontSize(9); doc.setTextColor(0);
                doc.splitTextToSize(notesText, 165).forEach(l => { if (y > 270) { doc.addPage(); y = 20; } doc.text(l, 20, y); y += 4; });
            }
            
            // AI Results
            if (includeAI) {
                const aiEntries = Object.entries(aiResults).filter(([k, v]) => v !== null);
                if (aiEntries.length > 0) {
                    y += 8; if (y > 230) { doc.addPage(); y = 20; }
                    doc.setFontSize(14); doc.setTextColor(124,58,237); doc.text('ANALISI AI', 20, y); y += 10;
                    
                    // Pre-cattura tutti gli schemi con dimensioni corrette
                    const schemaImages = {};
                    for (const [action, result] of aiEntries) {
                        if (result.type === 'schema' && result.code) {
                            try {
                                // Renderizza lo schema nel container
                                const id = 'pdf-mermaid-' + Date.now() + '-' + Math.random().toString(36).substr(2, 5);
                                const { svg } = await mermaid.render(id, result.code);
                                $('mermaidRender').innerHTML = svg;
                                $('mermaidContainer').style.display = 'block';
                                
                                // Attendi il rendering completo
                                await new Promise(r => setTimeout(r, 100));
                                
                                // Cattura con html2canvas e ottieni dimensioni
                                const imgData = await captureMermaidForPDF();
                                if (imgData) schemaImages[action] = imgData;
                            } catch (e) {
                                console.warn('Pre-render failed for', action, e);
                            }
                        }
                    }
                    
                    for (const [action, result] of aiEntries) {
                        if (y > 250) { doc.addPage(); y = 20; }
                        doc.setFontSize(11); doc.setTextColor(0,150,120); doc.text(result.title, 20, y); y += 7;
                        doc.setFontSize(9); doc.setTextColor(0);
                        
                        if (result.type === 'text') {
                            doc.splitTextToSize(result.content, 165).forEach(l => { 
                                if (y > 270) { doc.addPage(); y = 20; } 
                                doc.text(l, 20, y); y += 4; 
                            });
                        } else if (result.type === 'schema') {
                            let imageAdded = false;
                            
                            // Usa l'immagine pre-catturata con proporzioni corrette per A4
                            if (schemaImages[action]) {
                                try {
                                    const imgInfo = schemaImages[action];
                                    const pageWidth = 170; // mm disponibili (A4 - margini)
                                    const pageHeight = 257; // mm disponibili verticalmente
                                    const maxImgHeight = 140; // mm max per singolo schema
                                    
                                    // Calcola aspect ratio
                                    const aspectRatio = imgInfo.height / imgInfo.width;
                                    
                                    // Inizia con larghezza piena
                                    let imgWidth = pageWidth;
                                    let imgHeight = pageWidth * aspectRatio;
                                    
                                    // Se troppo alta, scala per rientrare
                                    if (imgHeight > maxImgHeight) {
                                        imgHeight = maxImgHeight;
                                        imgWidth = maxImgHeight / aspectRatio;
                                    }
                                    
                                    // Assicurati che non sia troppo stretta
                                    if (imgWidth < 80) {
                                        imgWidth = 80;
                                        imgHeight = 80 * aspectRatio;
                                    }
                                    
                                    // Se non c'√® spazio nella pagina corrente, nuova pagina
                                    const spaceNeeded = imgHeight + 25; // immagine + codice sotto
                                    if (y + spaceNeeded > pageHeight) { 
                                        doc.addPage(); 
                                        y = 25; 
                                    }
                                    
                                    // Centra orizzontalmente
                                    const xOffset = 20 + (pageWidth - imgWidth) / 2;
                                    
                                    doc.addImage(imgInfo.data, 'PNG', xOffset, y, imgWidth, imgHeight);
                                    y += imgHeight + 5;
                                    imageAdded = true;
                                } catch (e) {
                                    console.warn('Add image failed:', e);
                                }
                            }
                            
                            // Fallback: prova con SVG salvato
                            if (!imageAdded && result.svg) {
                                try {
                                    const imgData = await svgToImageWithDimensions(result.svg);
                                    if (imgData && imgData.data) {
                                        const pageWidth = 170;
                                        const maxImgHeight = 140;
                                        const aspectRatio = imgData.height / imgData.width;
                                        
                                        let imgWidth = pageWidth;
                                        let imgHeight = pageWidth * aspectRatio;
                                        
                                        if (imgHeight > maxImgHeight) {
                                            imgHeight = maxImgHeight;
                                            imgWidth = maxImgHeight / aspectRatio;
                                        }
                                        
                                        if (y + imgHeight + 20 > 257) { doc.addPage(); y = 25; }
                                        const xOffset = 20 + (pageWidth - imgWidth) / 2;
                                        doc.addImage(imgData.data, 'PNG', xOffset, y, imgWidth, imgHeight);
                                        y += imgHeight + 5;
                                        imageAdded = true;
                                    }
                                } catch (imgErr) {
                                    console.warn('SVG fallback failed:', imgErr);
                                }
                            }
                            
                            // Se ancora non c'√® immagine, mostra nota
                            if (!imageAdded) {
                                doc.setTextColor(100);
                                doc.setFontSize(9);
                                doc.text('[Schema generato - vedi codice sotto]', 20, y); 
                                y += 6;
                            }
                            
                            // Aggiungi il codice Mermaid (opzionale, pi√π compatto)
                            if (y > 250) { doc.addPage(); y = 20; }
                            doc.setFontSize(6); doc.setTextColor(150);
                            doc.text('Codice sorgente:', 20, y); y += 3;
                            const codeLines = result.code.split('\n').slice(0, 8);
                            codeLines.forEach(l => {
                                if (y > 280) { doc.addPage(); y = 20; }
                                doc.text(l.substring(0, 100), 22, y); y += 2.5;
                            });
                            if (result.code.split('\n').length > 8) {
                                doc.text('...', 22, y); y += 2.5;
                            }
                        }
                        y += 6;
                    }
                    
                    // Ripristina lo stato del container Mermaid
                    $('mermaidContainer').style.display = 'none';
                }
            }
            
            // Drawing
            if (includeDrawing && drawingHistory.length > 0) {
                doc.addPage();
                doc.setFontSize(12); doc.setTextColor(0,150,120); doc.text('DISEGNO', 20, 20);
                const imgData = getCanvasDataUrl();
                doc.addImage(imgData, 'PNG', 20, 30, 170, 100);
            }
            
            doc.save(`${pdfName.replace(/[^a-zA-Z0-9_-]/g, '_')}.pdf`); 
            showToast('‚úì PDF esportato');
        };
        
        // Funzione per convertire SVG in immagine PNG
        async function svgToImage(svgString) {
            return new Promise((resolve, reject) => {
                try {
                    // Pulisci e prepara l'SVG
                    let cleanSvg = svgString;
                    
                    // Estrai dimensioni dall'SVG o usa default
                    let width = 800, height = 400;
                    const widthMatch = svgString.match(/width="([^"]+)"/);
                    const heightMatch = svgString.match(/height="([^"]+)"/);
                    if (widthMatch) width = parseFloat(widthMatch[1]) || 800;
                    if (heightMatch) height = parseFloat(heightMatch[1]) || 400;
                    
                    // Assicurati che l'SVG abbia xmlns
                    if (!cleanSvg.includes('xmlns=')) {
                        cleanSvg = cleanSvg.replace('<svg', '<svg xmlns="http://www.w3.org/2000/svg"');
                    }
                    
                    // Aggiungi sfondo bianco
                    cleanSvg = cleanSvg.replace(/<svg([^>]*)>/, '<svg$1><rect width="100%" height="100%" fill="white"/>');
                    
                    // Converti in base64
                    const svgBase64 = btoa(unescape(encodeURIComponent(cleanSvg)));
                    const dataUrl = 'data:image/svg+xml;base64,' + svgBase64;
                    
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        const scale = 2;
                        canvas.width = (img.naturalWidth || width) * scale;
                        canvas.height = (img.naturalHeight || height) * scale;
                        
                        const ctx = canvas.getContext('2d');
                        ctx.fillStyle = '#ffffff';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        ctx.scale(scale, scale);
                        ctx.drawImage(img, 0, 0);
                        
                        resolve(canvas.toDataURL('image/png', 1.0));
                    };
                    
                    img.onerror = () => {
                        // Fallback: prova con Blob URL
                        const blob = new Blob([cleanSvg], { type: 'image/svg+xml' });
                        const url = URL.createObjectURL(blob);
                        
                        const img2 = new Image();
                        img2.onload = () => {
                            const canvas = document.createElement('canvas');
                            canvas.width = width * 2;
                            canvas.height = height * 2;
                            const ctx = canvas.getContext('2d');
                            ctx.fillStyle = '#ffffff';
                            ctx.fillRect(0, 0, canvas.width, canvas.height);
                            ctx.scale(2, 2);
                            ctx.drawImage(img2, 0, 0);
                            URL.revokeObjectURL(url);
                            resolve(canvas.toDataURL('image/png', 1.0));
                        };
                        img2.onerror = () => {
                            URL.revokeObjectURL(url);
                            reject(new Error('SVG render failed'));
                        };
                        img2.src = url;
                    };
                    
                    img.src = dataUrl;
                } catch (err) {
                    reject(err);
                }
            });
        }
        
        // Cattura il contenitore Mermaid come immagine usando html2canvas
        async function captureMermaidAsImage() {
            const container = $('mermaidRender');
            if (!container || !container.innerHTML || container.style.display === 'none') return null;
            
            try {
                // Assicurati che il container sia visibile
                const wasHidden = $('mermaidContainer').style.display === 'none';
                if (wasHidden) $('mermaidContainer').style.display = 'block';
                
                // Usa html2canvas per catturare
                const canvas = await html2canvas(container, {
                    backgroundColor: '#ffffff',
                    scale: 2,
                    useCORS: true,
                    logging: false,
                    allowTaint: true
                });
                
                if (wasHidden) $('mermaidContainer').style.display = 'none';
                
                return canvas.toDataURL('image/png', 1.0);
            } catch (e) {
                console.warn('html2canvas failed:', e);
                
                // Fallback: prova con SVG interno
                try {
                    const svgEl = container.querySelector('svg');
                    if (svgEl) {
                        const serializer = new XMLSerializer();
                        let svgString = serializer.serializeToString(svgEl);
                        return await svgToImage(svgString);
                    }
                } catch (e2) {
                    console.warn('SVG fallback failed:', e2);
                }
            }
            return null;
        }
        
        // Cattura Mermaid per PDF con dimensioni corrette
        async function captureMermaidForPDF() {
            const container = $('mermaidRender');
            if (!container || !container.innerHTML) return null;
            
            try {
                const wasHidden = $('mermaidContainer').style.display === 'none';
                if (wasHidden) $('mermaidContainer').style.display = 'block';
                
                // Aggiungi classe per cattura PDF (dimensioni fisse)
                container.classList.add('pdf-capture');
                
                // Forza layout
                await new Promise(r => setTimeout(r, 50));
                
                // Ottieni l'SVG per le dimensioni originali
                const svgEl = container.querySelector('svg');
                let origWidth = container.scrollWidth || 700;
                let origHeight = container.scrollHeight || 400;
                
                if (svgEl) {
                    // Imposta dimensioni fisse sull'SVG per PDF
                    const currentWidth = svgEl.getAttribute('width');
                    const currentHeight = svgEl.getAttribute('height');
                    
                    // Se l'SVG non ha dimensioni fisse, impostiamole
                    if (!currentWidth || currentWidth.includes('%')) {
                        svgEl.style.width = '100%';
                        svgEl.style.maxWidth = '660px';
                    }
                    
                    // Attendi il re-render
                    await new Promise(r => setTimeout(r, 50));
                    
                    origWidth = container.scrollWidth;
                    origHeight = container.scrollHeight;
                }
                
                // Cattura con html2canvas
                const canvas = await html2canvas(container, {
                    backgroundColor: '#ffffff',
                    scale: 2,
                    useCORS: true,
                    logging: false,
                    allowTaint: true,
                    width: origWidth,
                    height: origHeight
                });
                
                // Rimuovi classe PDF
                container.classList.remove('pdf-capture');
                if (svgEl) {
                    svgEl.style.width = '';
                    svgEl.style.maxWidth = '';
                }
                
                if (wasHidden) $('mermaidContainer').style.display = 'none';
                
                return {
                    data: canvas.toDataURL('image/png', 1.0),
                    width: canvas.width / 2,
                    height: canvas.height / 2,
                    originalWidth: origWidth,
                    originalHeight: origHeight
                };
            } catch (e) {
                console.warn('captureMermaidForPDF failed:', e);
                $('mermaidRender').classList.remove('pdf-capture');
                return null;
            }
        }
        
        // Converti SVG in immagine con dimensioni
        async function svgToImageWithDimensions(svgString) {
            return new Promise((resolve, reject) => {
                try {
                    let cleanSvg = svgString;
                    
                    // Estrai dimensioni
                    let width = 600, height = 400;
                    const widthMatch = svgString.match(/width="([^"]+)"/);
                    const heightMatch = svgString.match(/height="([^"]+)"/);
                    const viewBoxMatch = svgString.match(/viewBox="([^"]+)"/);
                    
                    if (viewBoxMatch) {
                        const parts = viewBoxMatch[1].split(/\s+|,/).map(Number);
                        if (parts.length >= 4) {
                            width = parts[2] || width;
                            height = parts[3] || height;
                        }
                    }
                    if (widthMatch) width = parseFloat(widthMatch[1]) || width;
                    if (heightMatch) height = parseFloat(heightMatch[1]) || height;
                    
                    // Assicurati che l'SVG abbia xmlns
                    if (!cleanSvg.includes('xmlns=')) {
                        cleanSvg = cleanSvg.replace('<svg', '<svg xmlns="http://www.w3.org/2000/svg"');
                    }
                    
                    // Aggiungi sfondo bianco
                    cleanSvg = cleanSvg.replace(/<svg([^>]*)>/, '<svg$1><rect width="100%" height="100%" fill="white"/>');
                    
                    const svgBase64 = btoa(unescape(encodeURIComponent(cleanSvg)));
                    const dataUrl = 'data:image/svg+xml;base64,' + svgBase64;
                    
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        const scale = 2;
                        canvas.width = (img.naturalWidth || width) * scale;
                        canvas.height = (img.naturalHeight || height) * scale;
                        
                        const ctx = canvas.getContext('2d');
                        ctx.fillStyle = '#ffffff';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        ctx.scale(scale, scale);
                        ctx.drawImage(img, 0, 0);
                        
                        resolve({
                            data: canvas.toDataURL('image/png', 1.0),
                            width: canvas.width / scale,
                            height: canvas.height / scale
                        });
                    };
                    
                    img.onerror = () => reject(new Error('Image load failed'));
                    img.src = dataUrl;
                } catch (err) {
                    reject(err);
                }
            });
        }

        window.exportTXT = () => {
            if (!transcriptEntries.length && !notesText) return showToast('Nessun contenuto');
            let c = `VoiceScribe - ${new Date().toLocaleDateString('it-IT')}\n${'='.repeat(40)}\n\n`;
            if (transcriptEntries.length) {
                c += 'TRASCRIZIONE\n' + '-'.repeat(20) + '\n\n';
                transcriptEntries.forEach(e => { c += `[${e.time}] ${e.speakerName}:\n${e.text}\n\n`; });
            }
            if (notesText) { c += '\nNOTE\n' + '-'.repeat(20) + '\n\n' + notesText; }
            const a = document.createElement('a'); a.href = URL.createObjectURL(new Blob([c],{type:'text/plain;charset=utf-8'})); a.download = `voicescribe_${Date.now()}.txt`; a.click(); showToast('‚úì TXT');
        };

        window.exportAudio = () => { if (!audioBlob) return showToast('Nessun audio'); const a = document.createElement('a'); a.href = URL.createObjectURL(audioBlob); a.download = `voicescribe_${Date.now()}.webm`; a.click(); showToast('‚úì Audio'); };

        window.exportDrawing = () => {
            if (drawingHistory.length === 0) return showToast('Nessun disegno');
            const a = document.createElement('a');
            a.href = getCanvasDataUrl();
            a.download = `disegno_${Date.now()}.png`;
            a.click();
            showToast('‚úì Immagine');
        };

        window.saveSession = () => { 
            if (!transcriptEntries.length && !notesText && drawingHistory.length === 0) return showToast('Nessun contenuto'); 
            $('sessionNameInput').value = `Progetto ${new Date().toLocaleDateString('it-IT')}`; 
            $('saveModal').classList.add('active'); 
        };

        window.confirmSaveSession = async () => {
            const name = $('sessionNameInput').value.trim(); if (!name) return;
            const sessionId = Date.now();
            
            // Save audio
            if (audioBlob) { try { await saveSessionAudio(sessionId, audioBlob); } catch (e) {} }
            
            // Save drawing
            const drawingData = drawingHistory.length > 0 ? getCanvasDataUrl() : null;
            if (drawingData) { try { await saveSessionDrawing(sessionId, drawingData); } catch (e) {} }
            
            // Check if we have any AI results
            const hasAiResults = Object.values(aiResults).some(r => r !== null);
            
            savedRecordings.push({ 
                id: sessionId, name, date: new Date().toISOString(), duration: $('timer').textContent, 
                entries: transcriptEntries, speakers, notes: notesText,
                hasAudio: !!audioBlob, hasDrawing: drawingHistory.length > 0, hasNotes: !!notesText,
                hasAI: hasAiResults, aiResults: hasAiResults ? {...aiResults} : null
            });
            localStorage.setItem('voicescribe_recordings', JSON.stringify(savedRecordings));
            $('saveModal').classList.remove('active'); 
            renderSavedRecordings(); 
            showToast('‚úì Progetto salvato');
        };

        // Saved Recordings
        function renderSavedRecordings() {
            const c = $('recordingsList');
            c.innerHTML = savedRecordings.length ? savedRecordings.map(r => `
                <div class="recording-item">
                    <div class="recording-item-icon">üìÅ</div>
                    <div class="recording-item-info">
                        <div class="recording-item-title">${r.name}</div>
                        <div class="recording-item-meta">${new Date(r.date).toLocaleDateString('it-IT')} ‚Ä¢ ${r.duration}</div>
                        <div class="recording-item-badges">
                            ${r.hasAudio ? '<span class="item-badge audio">üéµ Audio</span>' : ''}
                            ${r.hasNotes ? '<span class="item-badge notes">üìù Note</span>' : ''}
                            ${r.hasDrawing ? '<span class="item-badge drawing">‚úèÔ∏è Disegno</span>' : ''}
                            ${r.hasAI ? '<span class="item-badge ai">ü§ñ AI</span>' : ''}
                        </div>
                    </div>
                    <div class="recording-item-actions">
                        <button class="action-btn" onclick="loadRec(${r.id})" title="Carica">üìÇ</button>
                        <button class="action-btn" onclick="exportProjectJSON(${r.id})" title="Esporta JSON" style="color: var(--accent);">üì§</button>
                        <button class="action-btn delete" onclick="delRec(${r.id})" title="Elimina">üóëÔ∏è</button>
                    </div>
                </div>
            `).join('') : '<div class="empty-state"><svg viewBox="0 0 24 24" fill="currentColor"><path d="M20 6h-8l-2-2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2z"/></svg><p>Nessun progetto</p></div>';
        }

        window.loadRec = async (id) => {
            const r = savedRecordings.find(x => x.id === id); if (!r) return;
            transcriptEntries = [...r.entries]; 
            if (r.speakers) speakers = [...r.speakers]; 
            $('timer').textContent = r.duration;
            
            // Load notes
            notesText = r.notes || '';
            $('notesTextarea').value = notesText;
            $('notesCharCount').textContent = notesText.length;
            
            // Load audio
            if (r.hasAudio) audioBlob = await getSessionAudio(id);
            
            // Load drawing
            if (r.hasDrawing) {
                const drawingData = await getSessionDrawing(id);
                if (drawingData) {
                    drawingHistory = []; // Reset history (we'll use the image directly)
                    loadCanvasFromDataUrl(drawingData);
                }
            }
            
            // Load AI results
            if (r.hasAI && r.aiResults) {
                aiResults = {...r.aiResults};
                // Display last AI result if available
                const lastResult = Object.entries(aiResults).find(([k, v]) => v !== null);
                if (lastResult) {
                    const [action, result] = lastResult;
                    if (result.type === 'schema') {
                        $('aiResult').innerHTML = `<div class="ai-result-title">${result.title}</div><div class="ai-result-content">Schema caricato dal progetto.</div>`;
                        $('mermaidCode').textContent = result.code;
                        if (result.svg) {
                            $('mermaidRender').innerHTML = result.svg;
                        } else {
                            try {
                                const { svg } = await mermaid.render('mermaid-svg-' + Date.now(), result.code);
                                $('mermaidRender').innerHTML = svg;
                            } catch (e) {
                                $('mermaidRender').innerHTML = '<div style="color: #666; padding: 1rem;">Errore rendering</div>';
                            }
                        }
                        $('mermaidContainer').style.display = 'block';
                        lastMermaidCode = result.code;
                    } else {
                        $('aiResult').innerHTML = `<div class="ai-result-title">${result.title}</div><div class="ai-result-content">${result.content}</div>`;
                        $('mermaidContainer').style.display = 'none';
                    }
                }
            } else {
                aiResults = { correct: null, summary: null, keypoints: null, improve: null, flowchart: null, mindmap: null, timeline: null, relations: null };
                $('aiResult').innerHTML = '<div class="ai-result-empty">Seleziona un\'azione AI</div>';
                $('mermaidContainer').style.display = 'none';
            }
            
            updateSpeakerChips(); renderAllEntries();
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            document.querySelector('[data-tab="record"]').classList.add('active'); 
            $('recordTab').classList.add('active');
            showToast(`‚úì Caricato: ${r.name}`);
        };

        window.delRec = async (id) => { 
            if (!confirm('Eliminare progetto?')) return; 
            try { await deleteSessionAudio(id); } catch (e) {}
            try { await deleteSessionDrawing(id); } catch (e) {}
            savedRecordings = savedRecordings.filter(r => r.id !== id); 
            localStorage.setItem('voicescribe_recordings', JSON.stringify(savedRecordings)); 
            renderSavedRecordings(); 
            showToast('Eliminato'); 
        };
        
        // Export single project as JSON
        window.exportProjectJSON = async (id) => {
            const r = savedRecordings.find(x => x.id === id);
            if (!r) return showToast('‚ö†Ô∏è Progetto non trovato');
            
            const projectData = { ...r };
            
            // Include audio as base64 if available
            if (r.hasAudio) {
                try {
                    const audioBlob = await getSessionAudio(id);
                    if (audioBlob) {
                        const reader = new FileReader();
                        const audioBase64 = await new Promise((resolve) => {
                            reader.onloadend = () => resolve(reader.result);
                            reader.readAsDataURL(audioBlob);
                        });
                        projectData.audioData = audioBase64;
                    }
                } catch (e) { console.error('Audio export error:', e); }
            }
            
            // Include drawing if available
            if (r.hasDrawing) {
                try {
                    const drawingData = await getSessionDrawing(id);
                    if (drawingData) projectData.drawingData = drawingData;
                } catch (e) { console.error('Drawing export error:', e); }
            }
            
            const jsonStr = JSON.stringify(projectData, null, 2);
            const blob = new Blob([jsonStr], { type: 'application/json' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = `${r.name.replace(/[^a-zA-Z0-9_-]/g, '_')}.json`;
            a.click();
            showToast('‚úì Progetto esportato');
        };
        
        // Import project from JSON
        window.importProject = () => $('projectFileInput').click();
        
        $('projectFileInput').onchange = async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            // Verifica che sia un file JSON
            if (!file.name.endsWith('.json') && file.type !== 'application/json') {
                showToast('‚ö†Ô∏è Seleziona un file .json');
                e.target.value = '';
                return;
            }
            
            try {
                const text = await file.text();
                
                let projectData;
                try {
                    projectData = JSON.parse(text);
                } catch (parseErr) {
                    throw new Error('File JSON non valido');
                }
                
                // Validate required fields
                if (!projectData.name) {
                    throw new Error('Il file non contiene un nome progetto');
                }
                if (!projectData.entries || !Array.isArray(projectData.entries)) {
                    projectData.entries = [];
                }
                
                // Generate new ID to avoid conflicts
                const newId = Date.now();
                projectData.id = newId;
                projectData.date = projectData.date || new Date().toISOString();
                projectData.duration = projectData.duration || '00:00';
                
                // Save audio if present
                if (projectData.audioData) {
                    try {
                        const response = await fetch(projectData.audioData);
                        const audioBlob = await response.blob();
                        await saveSessionAudio(newId, audioBlob);
                        projectData.hasAudio = true;
                    } catch (audioErr) {
                        console.warn('Audio import skipped:', audioErr.message);
                        projectData.hasAudio = false;
                    }
                    delete projectData.audioData;
                }
                
                // Save drawing if present
                if (projectData.drawingData) {
                    try {
                        await saveSessionDrawing(newId, projectData.drawingData);
                        projectData.hasDrawing = true;
                    } catch (drawErr) {
                        console.warn('Drawing import skipped:', drawErr.message);
                        projectData.hasDrawing = false;
                    }
                    delete projectData.drawingData;
                }
                
                savedRecordings.push(projectData);
                localStorage.setItem('voicescribe_recordings', JSON.stringify(savedRecordings));
                renderSavedRecordings();
                showToast(`‚úì Importato: ${projectData.name}`);
                
            } catch (err) {
                console.error('Import error:', err);
                showToast('‚ö†Ô∏è ' + (err.message || 'Errore importazione'));
            }
            
            e.target.value = '';
        };

        // Events
        function setupEvents() {
            $('recordBtn').onclick = () => { if (isProcessing) return; isRecording ? stopRecording() : startRecording(); };
            document.querySelectorAll('.tab').forEach(tab => {
                tab.onclick = () => {
                    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                    tab.classList.add('active'); $(`${tab.dataset.tab}Tab`).classList.add('active');
                    if (tab.dataset.tab === 'notes') setTimeout(resizeCanvas, 100);
                };
            });
            ['sessionNameInput', 'whisperKeyInput', 'llamaKeyInput', 'gemmaKeyInput', 'newSpeakerInput', 'pdfNameInput'].forEach(id => {
                if ($(id)) {
                    $(id).onkeypress = e => { 
                        if (e.key === 'Enter') { 
                            if (id.includes('Key')) $('saveKeysBtn').click(); 
                            else if (id === 'sessionNameInput') confirmSaveSession(); 
                            else if (id === 'pdfNameInput') confirmExportPDF();
                            else confirmAddSpeaker(); 
                        } 
                    };
                }
            });
        }

        function showToast(msg) { const t = $('toast'); t.textContent = msg; t.classList.add('show'); setTimeout(() => t.classList.remove('show'), 2500); }

        window.newTranscript = () => {
            if (isRecording) return showToast('‚ö†Ô∏è Ferma registrazione');
            if (!transcriptEntries.length && !notesText && drawingHistory.length === 0 && !Object.values(aiResults).some(r => r !== null)) {
                return showToast('Gi√† vuoto');
            }
            if (confirm('Cancellare tutto?')) {
                transcriptEntries = []; audioBlob = null; notesText = '';
                $('timer').textContent = '00:00';
                $('notesTextarea').value = '';
                $('notesCharCount').textContent = '0';
                drawingHistory = [];
                redrawFromHistory();
                // Reset AI results
                aiResults = { correct: null, summary: null, keypoints: null, improve: null, flowchart: null, mindmap: null, timeline: null, relations: null };
                lastMermaidCode = '';
                $('mermaidContainer').style.display = 'none';
                renderAllEntries(); updateStats();
                $('aiResult').innerHTML = '<div class="ai-result-empty">Seleziona un\'azione AI</div>';
                showToast('‚úì Nuovo progetto');
            }
        };

        init();
    </script>
</body>
</html>
